{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/run-results/v6.json", "dbt_version": "1.8.6", "generated_at": "2024-09-10T15:31:22.555835Z", "invocation_id": "b8e60272-6582-44ec-a777-89af609a6e01", "env": {}}, "results": [{"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:20.849339Z", "completed_at": "2024-09-10T15:31:20.856667Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:20.857144Z", "completed_at": "2024-09-10T15:31:20.857159Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 0.0294342041015625, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo_source.stg_klaviyo__event_tmp", "compiled": true, "compiled_code": "\n    \n    \n        \n        \n        \n        select * \n    from \"postgres\".\"klaviyo_integration_tests\".\"event\"", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__event_tmp\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:20.829067Z", "completed_at": "2024-09-10T15:31:20.856911Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:20.858006Z", "completed_at": "2024-09-10T15:31:20.858009Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.030702829360961914, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo_source.stg_klaviyo__campaign_tmp", "compiled": true, "compiled_code": "\n    \n    \n        \n        \n        \n        select * \n    from \"postgres\".\"klaviyo_integration_tests\".\"campaign\"", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__campaign_tmp\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:20.851808Z", "completed_at": "2024-09-10T15:31:20.857576Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:20.858670Z", "completed_at": "2024-09-10T15:31:20.858673Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.03070521354675293, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo_source.stg_klaviyo__flow_tmp", "compiled": true, "compiled_code": "\n    \n    \n        \n        \n        \n        select * \n    from \"postgres\".\"klaviyo_integration_tests\".\"flow\"", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__flow_tmp\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:20.854055Z", "completed_at": "2024-09-10T15:31:20.857781Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:20.858995Z", "completed_at": "2024-09-10T15:31:20.858999Z"}], "thread_id": "Thread-4 (worker)", "execution_time": 0.0305938720703125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo_source.stg_klaviyo__metric_tmp", "compiled": true, "compiled_code": "\n    \n    \n        \n        \n        \n        select * \n    from \"postgres\".\"klaviyo_integration_tests\".\"metric\"", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__metric_tmp\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:20.864317Z", "completed_at": "2024-09-10T15:31:20.866161Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:20.868964Z", "completed_at": "2024-09-10T15:31:20.868969Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.008639812469482422, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.klaviyo_integration_tests.campaign", "compiled": null, "compiled_code": null, "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:20.866462Z", "completed_at": "2024-09-10T15:31:20.867475Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:20.869533Z", "completed_at": "2024-09-10T15:31:20.869538Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.008775949478149414, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.klaviyo_integration_tests.event", "compiled": null, "compiled_code": null, "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:20.867702Z", "completed_at": "2024-09-10T15:31:20.868714Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:20.869878Z", "completed_at": "2024-09-10T15:31:20.869882Z"}], "thread_id": "Thread-4 (worker)", "execution_time": 0.008901119232177734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.klaviyo_integration_tests.flow", "compiled": null, "compiled_code": null, "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:20.861530Z", "completed_at": "2024-09-10T15:31:20.869319Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:20.870490Z", "completed_at": "2024-09-10T15:31:20.870494Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 0.010902881622314453, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo_source.stg_klaviyo__person_tmp", "compiled": true, "compiled_code": "\n    \n    \n        \n        \n        \n        select * \n    from \"postgres\".\"klaviyo_integration_tests\".\"person\"", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__person_tmp\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:20.872937Z", "completed_at": "2024-09-10T15:31:20.874025Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:20.887117Z", "completed_at": "2024-09-10T15:31:20.887124Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.015896081924438477, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.klaviyo_integration_tests.metric", "compiled": null, "compiled_code": null, "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:20.874410Z", "completed_at": "2024-09-10T15:31:20.875458Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:20.891407Z", "completed_at": "2024-09-10T15:31:20.891413Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.019700050354003906, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.klaviyo_integration_tests.person", "compiled": null, "compiled_code": null, "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:20.894061Z", "completed_at": "2024-09-10T15:31:21.145742Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:21.145970Z", "completed_at": "2024-09-10T15:31:21.145978Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.29952311515808105, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo_source.stg_klaviyo__flow", "compiled": true, "compiled_code": "with base as (\n\n    select * \n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__flow_tmp\"\n\n),\n\nfields as (\n\n    select\n        \n    \n    \n    _fivetran_deleted\n    \n as \n    \n    _fivetran_deleted\n    \n, \n    \n    \n    _fivetran_synced\n    \n as \n    \n    _fivetran_synced\n    \n, \n    \n    \n    created\n    \n as \n    \n    created\n    \n, \n    \n    \n    id\n    \n as \n    \n    id\n    \n, \n    \n    \n    name\n    \n as \n    \n    name\n    \n, \n    \n    \n    status\n    \n as \n    \n    status\n    \n, \n    \n    \n    updated\n    \n as \n    \n    updated\n    \n, \n    \n    \n    archived\n    \n as \n    \n    archived\n    \n, \n    \n    \n    trigger_type\n    \n as \n    \n    trigger_type\n    \n\n\n\n        \n\n\n, cast('' as TEXT) as source_relation\n\n\n\n    from base\n),\n\nfinal as (\n    \n    select \n        created as created_at,\n        cast(id as TEXT ) as flow_id,\n        name as flow_name,\n        status,\n        updated as updated_at,\n        archived as is_archived,\n        trigger_type,\n        source_relation\n\n    from fields\n    where not coalesce(_fivetran_deleted, false)\n)\n\nselect * from final", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__flow\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:20.875675Z", "completed_at": "2024-09-10T15:31:21.193495Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:21.194153Z", "completed_at": "2024-09-10T15:31:21.194157Z"}], "thread_id": "Thread-4 (worker)", "execution_time": 0.34851884841918945, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo_source.stg_klaviyo__event", "compiled": true, "compiled_code": "with base as (\n\n    select * \n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__event_tmp\"\n\n),\n\nfields as (\n\n    select\n        \n    \n    \n    _fivetran_deleted\n    \n as \n    \n    _fivetran_deleted\n    \n, \n    \n    \n    _fivetran_synced\n    \n as \n    \n    _fivetran_synced\n    \n, \n    \n    \n    _variation\n    \n as \n    \n    _variation\n    \n, \n    \n    \n    campaign_id\n    \n as \n    \n    campaign_id\n    \n, \n    \n    \n    datetime\n    \n as \n    \n    datetime\n    \n, \n    \n    \n    flow_id\n    \n as \n    \n    flow_id\n    \n, \n    \n    \n    flow_message_id\n    \n as \n    \n    flow_message_id\n    \n, \n    \n    \n    id\n    \n as \n    \n    id\n    \n, \n    \n    \n    metric_id\n    \n as \n    \n    metric_id\n    \n, \n    \n    \n    person_id\n    \n as \n    \n    person_id\n    \n, \n    \n    \n    timestamp\n    \n as \n    \n    timestamp\n    \n, \n    \n    \n    type\n    \n as \n    \n    type\n    \n, \n    \n    \n    uuid\n    \n as \n    \n    uuid\n    \n, \n    \n    \n    property_value\n    \n as \n    \n    property_value\n    \n\n\n\n        \n\n\n, cast('' as TEXT) as source_relation\n\n\n\n    from base\n),\n\nrename as (\n    \n    select \n        _variation as variation_id,\n        cast(campaign_id as TEXT ) as campaign_id,\n        cast(timestamp as timestamp ) as occurred_at,\n        cast(flow_id as TEXT ) as flow_id,\n        flow_message_id,\n        cast(id as TEXT ) as event_id,\n        cast(metric_id as TEXT ) as metric_id,\n        cast(person_id as TEXT ) as person_id,\n        type,\n        uuid,\n        \n\n    cast(regexp_replace(cast(property_value as TEXT), '[^0-9.]*', '', 'g') as numeric(28,6))\n\n as numeric_value,\n        cast(_fivetran_synced as timestamp ) as _fivetran_synced,\n        source_relation\n        \n\n\n\n\n\n    from fields\n    where not coalesce(_fivetran_deleted, false)\n),\n\nfinal as (\n    \n    select \n        *,\n        cast( date_trunc('day', occurred_at) as date) as occurred_on,\n        md5(cast(coalesce(cast(event_id as TEXT), '_dbt_utils_surrogate_key_null_') || '-' || coalesce(cast(source_relation as TEXT), '_dbt_utils_surrogate_key_null_') as TEXT)) as unique_event_id\n\n    from rename\n\n)\n\nselect * from final", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__event\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:20.887521Z", "completed_at": "2024-09-10T15:31:21.191776Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:21.192764Z", "completed_at": "2024-09-10T15:31:21.192769Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 0.34877896308898926, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo_source.stg_klaviyo__campaign", "compiled": true, "compiled_code": "with base as (\n\n    select * \n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__campaign_tmp\"\n\n),\n\nfields as (\n\n    select\n        \n    \n    \n    _fivetran_deleted\n    \n as \n    \n    _fivetran_deleted\n    \n, \n    \n    \n    _fivetran_synced\n    \n as \n    \n    _fivetran_synced\n    \n, \n    \n    \n    campaign_type\n    \n as \n    \n    campaign_type\n    \n, \n    \n    \n    created\n    \n as \n    \n    created\n    \n, \n    \n    \n    email_template_id\n    \n as \n    \n    email_template_id\n    \n, \n    \n    \n    from_email\n    \n as \n    \n    from_email\n    \n, \n    \n    \n    from_name\n    \n as \n    \n    from_name\n    \n, \n    \n    \n    id\n    \n as \n    \n    id\n    \n, \n    \n    \n    name\n    \n as \n    \n    name\n    \n, \n    \n    \n    send_time\n    \n as \n    \n    send_time\n    \n, \n    \n    \n    sent_at\n    \n as \n    \n    sent_at\n    \n, \n    \n    \n    status\n    \n as \n    \n    status\n    \n, \n    \n    \n    status_id\n    \n as \n    \n    status_id\n    \n, \n    \n    \n    status_label\n    \n as \n    \n    status_label\n    \n, \n    \n    \n    subject\n    \n as \n    \n    subject\n    \n, \n    \n    \n    updated\n    \n as \n    \n    updated\n    \n, \n    \n    \n    archived\n    \n as \n    \n    archived\n    \n, \n    \n    \n    scheduled\n    \n as \n    \n    scheduled\n    \n\n\n\n        \n\n\n, cast('' as TEXT) as source_relation\n\n\n\n    from base\n),\n\nfinal as (\n    \n    select\n        campaign_type,\n        created as created_at,\n        email_template_id,\n        from_email,\n        from_name,\n        cast(id as TEXT ) as campaign_id,\n        name as campaign_name,\n        send_time as scheduled_to_send_at,\n        sent_at,\n        coalesce(status, lower(status_label)) as status,\n        status_id,\n        subject,\n        updated as updated_at,\n        archived as is_archived,\n        scheduled as scheduled_at,\n        source_relation\n\n    from fields\n\n    where not coalesce(_fivetran_deleted, false)\n)\n\nselect * from final", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__campaign\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:20.898221Z", "completed_at": "2024-09-10T15:31:21.192103Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:21.192986Z", "completed_at": "2024-09-10T15:31:21.192989Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.3282041549682617, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo_source.stg_klaviyo__metric", "compiled": true, "compiled_code": "with base as (\n\n    select * \n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__metric_tmp\"\n\n),\n\nfields as (\n\n    select\n        \n    \n    \n    _fivetran_deleted\n    \n as \n    \n    _fivetran_deleted\n    \n, \n    \n    \n    _fivetran_synced\n    \n as \n    \n    _fivetran_synced\n    \n, \n    \n    \n    created\n    \n as \n    \n    created\n    \n, \n    \n    \n    id\n    \n as \n    \n    id\n    \n, \n    \n    \n    integration_id\n    \n as \n    \n    integration_id\n    \n, \n    \n    \n    integration_category\n    \n as \n    \n    integration_category\n    \n, \n    \n    \n    integration_name\n    \n as \n    \n    integration_name\n    \n, \n    \n    \n    name\n    \n as \n    \n    name\n    \n, \n    \n    \n    updated\n    \n as \n    \n    updated\n    \n\n\n\n        \n\n\n, cast('' as TEXT) as source_relation\n\n\n\n    from base\n),\n\nfinal as (\n    \n    select \n        created as created_at,\n        cast(id as TEXT ) as metric_id,\n        cast(integration_id as TEXT ) as integration_id,\n        integration_name,\n        integration_category,\n        name as metric_name,\n        updated as updated_at,\n        source_relation\n\n    from fields\n\n    where not coalesce(_fivetran_deleted, false)\n)\n\nselect * from final", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__metric\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:21.223289Z", "completed_at": "2024-09-10T15:31:21.249532Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:21.249917Z", "completed_at": "2024-09-10T15:31:21.249927Z"}], "thread_id": "Thread-4 (worker)", "execution_time": 0.028162002563476562, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo_source.dbt_utils_unique_combination_of_columns_stg_klaviyo__flow_flow_id__source_relation.015215d481", "compiled": true, "compiled_code": "\n\n\n\n\n\nwith validation_errors as (\n\n    select\n        flow_id, source_relation\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__flow\"\n    group by flow_id, source_relation\n    having count(*) > 1\n\n)\n\nselect *\nfrom validation_errors\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:21.231323Z", "completed_at": "2024-09-10T15:31:21.251035Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:21.251668Z", "completed_at": "2024-09-10T15:31:21.251671Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 0.028882980346679688, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo_source.not_null_stg_klaviyo__flow_flow_id.a00a897e42", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect flow_id\nfrom \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__flow\"\nwhere flow_id is null\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:21.236417Z", "completed_at": "2024-09-10T15:31:21.251229Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:21.252015Z", "completed_at": "2024-09-10T15:31:21.252019Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.02899789810180664, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo.int_klaviyo__event_attribution", "compiled": true, "compiled_code": "\n\nwith events as (\n\n    select \n        *,\n        -- no event will be attributed to both a campaign and flow\n        coalesce(campaign_id, flow_id) as touch_id,\n        case \n            when campaign_id is not null then 'campaign' \n            when flow_id is not null then 'flow' \n        else null end as touch_type -- defintion: touch = interaction with campaign/flow\n\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__event\"\n\n    \n    -- grab **ALL** events for users who have any events in this new increment\n    where person_id in (\n\n        select distinct person_id\n        from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__event\"\n\n        -- most events (from all kinds of integrations) at least once every hour\n        -- https://help.klaviyo.com/hc/en-us/articles/115005253208\n        where _fivetran_synced >= cast(coalesce( \n            (\n                select \n\n    max(_fivetran_synced) + ((interval '1 hour') * (-1))\n\n  \n                from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"int_klaviyo__event_attribution\"\n            ), '2012-01-01') as timestamp ) -- klaviyo was founded in 2012, so let's default the min date to then\n    )\n    \n),\n\n-- sessionize events based on attribution eligibility -- is it the right kind of event, and does it have a campaign or flow?\ncreate_sessions as (\n    select\n        *,\n        -- default klaviyo__event_attribution_filter limits attribution-eligible events to to email opens, email clicks, and sms opens\n        -- https://help.klaviyo.com/hc/en-us/articles/115005248128\n\n        -- events that come with flow/campaign attributions (and are eligible event types) will create new sessions.\n        -- non-attributed events that come in afterward will be batched into the same attribution-session\n        sum(case when touch_id is not null\n        \n            and lower(type) in ('opened email', 'clicked email', 'clicked sms')\n        \n            then 1 else 0 end) over (\n                partition by person_id, source_relation order by occurred_at asc rows between unbounded preceding and current row) as touch_session \n\n    from events\n\n),\n\n-- \"session start\" refers to the event in a \"touch session\" that is already attributed with a campaign or flow by Klaviyo\n-- a new event that is attributed with a campaign/flow will trigger a new session, so there will only be one already-attributed event per each session \n-- events that are missing attributions will borrow data from the event that triggered the session, if they are in the lookback window (see `attribute` CTE)\nlast_touches as (\n\n    select \n        *,\n        -- when did the touch session begin?\n        min(occurred_at) over(partition by person_id, source_relation, touch_session) as session_start_at,\n\n        -- get the kind of metric/event that triggered the attribution session, in order to decide \n        -- to use the sms or email lookback value. \n        first_value(type) over(\n            partition by person_id, source_relation, touch_session order by occurred_at asc rows between unbounded preceding and current row) as session_event_type\n\n    from create_sessions\n),\n\nattribute as (\n\n    select \n        *,\n        -- klaviyo uses different lookback windows for email and sms events\n        -- default email lookback = 5 days (120 hours) -> https://help.klaviyo.com/hc/en-us/articles/115005248128#conversion-tracking1\n        -- default sms lookback: 1 day (24 hours -> https://help.klaviyo.com/hc/en-us/articles/115005248128#sms-conversion-tracking7\n\n        coalesce(touch_id, -- use pre-attributed flow/campaign if provided\n            case \n            when \n        (\n        ((occurred_at)::date - (session_start_at)::date)\n     * 24 + date_part('hour', (occurred_at)::timestamp) - date_part('hour', (session_start_at)::timestamp))\n     <= (\n                case \n                when lower(session_event_type) like '%sms%' then 24\n                else 120 end\n            ) -- if the events fall within the lookback window, attribute\n            then first_value(touch_id) over (\n                partition by person_id, source_relation, touch_session order by occurred_at asc rows between unbounded preceding and current row)\n            else null end) as last_touch_id -- session qualified for attribution -> we will call this \"last touch\"\n\n    from last_touches \n),\n\nfinal as (\n\n    select\n        *,\n\n        -- get whether the event is attributed to a flow or campaign\n        coalesce(touch_type, first_value(touch_type) over(\n            partition by person_id, source_relation, touch_session order by occurred_at asc rows between unbounded preceding and current row)) \n\n            as session_touch_type -- if the session events qualified for attribution, extract the type of touch they are attributed to\n\n    from attribute \n)\n\nselect * from final", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"int_klaviyo__event_attribution\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:21.252363Z", "completed_at": "2024-09-10T15:31:21.256695Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:21.259588Z", "completed_at": "2024-09-10T15:31:21.259593Z"}], "thread_id": "Thread-4 (worker)", "execution_time": 0.00886082649230957, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo_source.dbt_utils_unique_combination_of_columns_stg_klaviyo__event_event_id__source_relation.3778c651d7", "compiled": true, "compiled_code": "\n\n\n\n\n\nwith validation_errors as (\n\n    select\n        event_id, source_relation\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__event\"\n    group by event_id, source_relation\n    having count(*) > 1\n\n)\n\nselect *\nfrom validation_errors\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:21.257104Z", "completed_at": "2024-09-10T15:31:21.263975Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:21.264425Z", "completed_at": "2024-09-10T15:31:21.264429Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 0.008484125137329102, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo_source.not_null_stg_klaviyo__event_event_id.7a09ac6ec1", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect event_id\nfrom \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__event\"\nwhere event_id is null\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:21.259963Z", "completed_at": "2024-09-10T15:31:21.264756Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:21.267912Z", "completed_at": "2024-09-10T15:31:21.267916Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.011699914932250977, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo_source.dbt_utils_unique_combination_of_columns_stg_klaviyo__campaign_campaign_id__source_relation.59158488ff", "compiled": true, "compiled_code": "\n\n\n\n\n\nwith validation_errors as (\n\n    select\n        campaign_id, source_relation\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__campaign\"\n    group by campaign_id, source_relation\n    having count(*) > 1\n\n)\n\nselect *\nfrom validation_errors\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:21.264952Z", "completed_at": "2024-09-10T15:31:21.268809Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:21.269458Z", "completed_at": "2024-09-10T15:31:21.269461Z"}], "thread_id": "Thread-4 (worker)", "execution_time": 0.0057599544525146484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo_source.dbt_utils_unique_combination_of_columns_stg_klaviyo__metric_metric_id__source_relation.e9f33c04e5", "compiled": true, "compiled_code": "\n\n\n\n\n\nwith validation_errors as (\n\n    select\n        metric_id, source_relation\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__metric\"\n    group by metric_id, source_relation\n    having count(*) > 1\n\n)\n\nselect *\nfrom validation_errors\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:21.269804Z", "completed_at": "2024-09-10T15:31:21.275634Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:21.278543Z", "completed_at": "2024-09-10T15:31:21.278549Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 0.010283708572387695, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo_source.not_null_stg_klaviyo__campaign_campaign_id.5dfc47dc1d", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect campaign_id\nfrom \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__campaign\"\nwhere campaign_id is null\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:21.272727Z", "completed_at": "2024-09-10T15:31:21.278330Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:21.278953Z", "completed_at": "2024-09-10T15:31:21.278956Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.009781122207641602, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo_source.not_null_stg_klaviyo__metric_metric_id.4759d62078", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect metric_id\nfrom \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__metric\"\nwhere metric_id is null\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:21.275871Z", "completed_at": "2024-09-10T15:31:21.282453Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:21.282732Z", "completed_at": "2024-09-10T15:31:21.282737Z"}], "thread_id": "Thread-4 (worker)", "execution_time": 0.007654905319213867, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo.dbt_utils_unique_combination_of_columns_int_klaviyo__event_attribution_event_id__source_relation.654b98ad2c", "compiled": true, "compiled_code": "\n\n\n\n\n\nwith validation_errors as (\n\n    select\n        event_id, source_relation\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"int_klaviyo__event_attribution\"\n    group by event_id, source_relation\n    having count(*) > 1\n\n)\n\nselect *\nfrom validation_errors\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:21.280051Z", "completed_at": "2024-09-10T15:31:21.283136Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:21.283346Z", "completed_at": "2024-09-10T15:31:21.283349Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 0.003786325454711914, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo.not_null_int_klaviyo__event_attribution_event_id.8d186152c4", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect event_id\nfrom \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"int_klaviyo__event_attribution\"\nwhere event_id is null\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:21.194576Z", "completed_at": "2024-09-10T15:31:21.448213Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:21.448444Z", "completed_at": "2024-09-10T15:31:21.448450Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.2777538299560547, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo_source.stg_klaviyo__person", "compiled": true, "compiled_code": "with base as (\n\n    select * \n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__person_tmp\"\n\n),\n\nfields as (\n\n    select\n        \n    \n    \n    _fivetran_deleted\n    \n as \n    \n    _fivetran_deleted\n    \n, \n    \n    \n    _fivetran_synced\n    \n as \n    \n    _fivetran_synced\n    \n, \n    \n    \n    address_1\n    \n as \n    \n    address_1\n    \n, \n    \n    \n    address_2\n    \n as \n    \n    address_2\n    \n, \n    \n    \n    city\n    \n as \n    \n    city\n    \n, \n    \n    \n    country\n    \n as \n    \n    country\n    \n, \n    \n    \n    created\n    \n as \n    \n    created\n    \n, \n    \n    \n    email\n    \n as \n    \n    email\n    \n, \n    \n    \n    first_name\n    \n as \n    \n    first_name\n    \n, \n    \n    \n    id\n    \n as \n    \n    id\n    \n, \n    \n    \n    last_name\n    \n as \n    \n    last_name\n    \n, \n    \n    \n    latitude\n    \n as \n    \n    latitude\n    \n, \n    \n    \n    longitude\n    \n as \n    \n    longitude\n    \n, \n    \n    \n    organization\n    \n as \n    \n    organization\n    \n, \n    \n    \n    phone_number\n    \n as \n    \n    phone_number\n    \n, \n    \n    \n    region\n    \n as \n    \n    region\n    \n, \n    \n    \n    timezone\n    \n as \n    \n    timezone\n    \n, \n    \n    \n    title\n    \n as \n    \n    title\n    \n, \n    \n    \n    updated\n    \n as \n    \n    updated\n    \n, \n    \n    \n    zip\n    \n as \n    \n    zip\n    \n, \n    \n    \n    last_event_date\n    \n as \n    \n    last_event_date\n    \n\n\n\n        \n\n\n, cast('' as TEXT) as source_relation\n\n\n\n    from base\n),\n\nfinal as (\n    \n    select \n        cast(id as TEXT ) as person_id,\n        address_1,\n        address_2,\n        city,\n        country,\n        zip,\n        created as created_at,\n        email,\n        first_name || ' ' || last_name as full_name,\n        latitude,\n        longitude,\n        organization,\n        phone_number,\n        region, -- state in USA\n        timezone,\n        title,\n        updated as updated_at,\n        last_event_date,\n        source_relation\n        \n        \n\n\n\n\n\n    from fields\n    where not coalesce(_fivetran_deleted, false)\n)\n\nselect * from final", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__person\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:21.472894Z", "completed_at": "2024-09-10T15:31:21.477300Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:21.477858Z", "completed_at": "2024-09-10T15:31:21.477863Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.005451679229736328, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo_source.dbt_utils_unique_combination_of_columns_stg_klaviyo__person_person_id__source_relation.33a4f9ca24", "compiled": true, "compiled_code": "\n\n\n\n\n\nwith validation_errors as (\n\n    select\n        person_id, source_relation\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__person\"\n    group by person_id, source_relation\n    having count(*) > 1\n\n)\n\nselect *\nfrom validation_errors\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:21.478191Z", "completed_at": "2024-09-10T15:31:21.497423Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:21.497644Z", "completed_at": "2024-09-10T15:31:21.497649Z"}], "thread_id": "Thread-4 (worker)", "execution_time": 0.02096104621887207, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo_source.not_null_stg_klaviyo__person_person_id.bd77ffc8aa", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect person_id\nfrom \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__person\"\nwhere person_id is null\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:21.480705Z", "completed_at": "2024-09-10T15:31:21.754855Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:21.755077Z", "completed_at": "2024-09-10T15:31:21.755083Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 0.303729772567749, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo.klaviyo__events", "compiled": true, "compiled_code": "\n-- ^ the incremental strategy is split into delete+insert for snowflake since there is a bit of\n-- overlap in transformed data blocks for incremental runs (we look back an extra hour, see lines 23 - 30)\n-- this configuration solution was taken from https://docs.getdbt.com/reference/resource-configs/snowflake-configs#merge-behavior-incremental-models\n\nwith events as (\n\n    select *\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"int_klaviyo__event_attribution\"\n\n    \n\n    -- most events (from all kinds of integrations) at least once every hour\n    where _fivetran_synced >= cast(coalesce( \n            (\n                select \n\n    max(_fivetran_synced) + ((interval '1 hour') * (-1))\n\n  \n                from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__events\"\n            ), '2012-01-01') as timestamp ) -- klaviyo was founded in 2012, so let's default the min date to then\n    \n),\n\nevent_fields as (\n\n    -- excluding some fields to rename them and/or make them null if needed\n    \n    -- as of the patch release of dbt-utils v0.7.3, the snowflake uppercasing is not needed anymore so we have deleted the snowflake conditional in the exclusion\n\n    select \n        \"variation_id\",\n  \"campaign_id\",\n  \"occurred_at\",\n  \"flow_id\",\n  \"flow_message_id\",\n  \"event_id\",\n  \"metric_id\",\n  \"person_id\",\n  \"uuid\",\n  \"numeric_value\",\n  \"_fivetran_synced\",\n  \"source_relation\",\n  \"occurred_on\",\n  \"unique_event_id\",\n  \"touch_id\",\n  \"touch_type\",\n\n        type, -- need to pull this out because it gets removed by dbt_utils.star, due to being a substring of 'session_event_type' and 'session_touch_type'\n\n        -- split out campaign and flow IDs\n        case \n            when session_touch_type = 'campaign' then last_touch_id \n        else null end as last_touch_campaign_id,\n        case \n            when session_touch_type = 'flow' then last_touch_id \n        else null end as last_touch_flow_id,\n\n        -- only make these non-null if the event indeed qualified for attribution\n        case \n            when last_touch_id is not null then session_start_at \n        else null end as last_touch_at,\n        case \n            when last_touch_id is not null then session_event_type \n        else null end as last_touch_event_type,\n        case \n            when last_touch_id is not null then session_touch_type \n        else null end as last_touch_type -- flow vs campaign\n\n    \n    from events\n),\n\ncampaign as (\n\n    select *\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__campaign\"\n),\n\nflow as (\n\n    select *\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__flow\"\n),\n\nperson as (\n\n    select *\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__person\"\n),\n\n-- just pulling this to join with INTEGRATION\nmetric as (\n\n    select *\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__metric\"\n),\n\njoin_fields as (\n\n    select\n        event_fields.*,\n        campaign.campaign_name,\n        campaign.campaign_type,\n        campaign.subject as campaign_subject_line,\n        flow.flow_name, \n        person.city as person_city,\n        person.country as person_country,\n        person.region as person_region,\n        person.email as person_email,\n        person.timezone as person_timezone,\n        metric.integration_id,\n        metric.integration_name,\n        metric.integration_category\n\n    from event_fields\n    left join campaign on (\n      event_fields.last_touch_campaign_id = campaign.campaign_id\n      and\n      event_fields.source_relation = campaign.source_relation\n    )\n    left join flow on (\n      event_fields.last_touch_flow_id = flow.flow_id\n      and\n      event_fields.source_relation = flow.source_relation  \n    )\n    left join person on (\n      event_fields.person_id = person.person_id\n      and\n      event_fields.source_relation = person.source_relation\n    )\n    left join metric on (\n      event_fields.metric_id = metric.metric_id\n      and\n      event_fields.source_relation = metric.source_relation\n    )\n)\n\nselect * from join_fields", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__events\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:21.783395Z", "completed_at": "2024-09-10T15:31:21.795899Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:21.796529Z", "completed_at": "2024-09-10T15:31:21.796536Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.01469111442565918, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo.klaviyo__person_campaign_flow", "compiled": true, "compiled_code": "with events as (\n    select *\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__events\"\n),\n\npivot_out_events as (\n    \n    select \n        person_id,\n        last_touch_campaign_id,\n        last_touch_flow_id,\n        campaign_name,\n        flow_name,\n        variation_id,\n        source_relation,\n        min(occurred_at) as first_event_at,\n        max(occurred_at) as last_event_at\n\n    -- sum up the numeric value associated with events (most likely will mean revenue)\n    \n    , sum(case when lower(type) = 'refunded order' then \n            coalesce(\n    case\n        when replace(cast(numeric_value as varchar),cast(' ' as varchar),cast('' as varchar)) ~ '^(0|[1-9][0-9]*)$' \n        then replace(cast(numeric_value as varchar),cast(' ' as varchar),cast('' as varchar))\n        else null\n    end::numeric\n\n\n\n, 0)\n            else 0 end) \n        as sum_revenue_refunded_order -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'placed order' then \n            coalesce(\n    case\n        when replace(cast(numeric_value as varchar),cast(' ' as varchar),cast('' as varchar)) ~ '^(0|[1-9][0-9]*)$' \n        then replace(cast(numeric_value as varchar),cast(' ' as varchar),cast('' as varchar))\n        else null\n    end::numeric\n\n\n\n, 0)\n            else 0 end) \n        as sum_revenue_placed_order -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'ordered product' then \n            coalesce(\n    case\n        when replace(cast(numeric_value as varchar),cast(' ' as varchar),cast('' as varchar)) ~ '^(0|[1-9][0-9]*)$' \n        then replace(cast(numeric_value as varchar),cast(' ' as varchar),cast('' as varchar))\n        else null\n    end::numeric\n\n\n\n, 0)\n            else 0 end) \n        as sum_revenue_ordered_product -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'checkout started' then \n            coalesce(\n    case\n        when replace(cast(numeric_value as varchar),cast(' ' as varchar),cast('' as varchar)) ~ '^(0|[1-9][0-9]*)$' \n        then replace(cast(numeric_value as varchar),cast(' ' as varchar),cast('' as varchar))\n        else null\n    end::numeric\n\n\n\n, 0)\n            else 0 end) \n        as sum_revenue_checkout_started -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'cancelled order' then \n            coalesce(\n    case\n        when replace(cast(numeric_value as varchar),cast(' ' as varchar),cast('' as varchar)) ~ '^(0|[1-9][0-9]*)$' \n        then replace(cast(numeric_value as varchar),cast(' ' as varchar),cast('' as varchar))\n        else null\n    end::numeric\n\n\n\n, 0)\n            else 0 end) \n        as sum_revenue_cancelled_order -- removing special characters that I have seen in different integration events\n    \n\n    -- count up the number of instances of each metric\n    \n    , sum(case when lower(type) = 'active on site' then 1 else 0 end) \n        as count_active_on_site -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'viewed product' then 1 else 0 end) \n        as count_viewed_product -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'ordered product' then 1 else 0 end) \n        as count_ordered_product -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'placed order' then 1 else 0 end) \n        as count_placed_order -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'refunded order' then 1 else 0 end) \n        as count_refunded_order -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'received email' then 1 else 0 end) \n        as count_received_email -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'clicked email' then 1 else 0 end) \n        as count_clicked_email -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'opened email' then 1 else 0 end) \n        as count_opened_email -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'marked email as spam' then 1 else 0 end) \n        as count_marked_email_as_spam -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'unsubscribed' then 1 else 0 end) \n        as count_unsubscribed -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'received sms' then 1 else 0 end) \n        as count_received_sms -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'clicked sms' then 1 else 0 end) \n        as count_clicked_sms -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'sent sms' then 1 else 0 end) \n        as count_sent_sms -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'unsubscribed from sms' then 1 else 0 end) \n        as count_unsubscribed_from_sms -- removing special characters that I have seen in different integration events\n    \n\n    from events\n    group by 1,2,3,4,5,6,7\n)\n\nselect *\nfrom pivot_out_events", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__person_campaign_flow\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:21.790772Z", "completed_at": "2024-09-10T15:31:21.796203Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:21.797000Z", "completed_at": "2024-09-10T15:31:21.797010Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.014734029769897461, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo.dbt_utils_unique_combination_of_columns_klaviyo__events_event_id__source_relation.847dad4174", "compiled": true, "compiled_code": "\n\n\n\n\n\nwith validation_errors as (\n\n    select\n        event_id, source_relation\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__events\"\n    group by event_id, source_relation\n    having count(*) > 1\n\n)\n\nselect *\nfrom validation_errors\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:21.793208Z", "completed_at": "2024-09-10T15:31:21.797478Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:21.797988Z", "completed_at": "2024-09-10T15:31:21.797993Z"}], "thread_id": "Thread-4 (worker)", "execution_time": 0.015067815780639648, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo.not_null_klaviyo__events_event_id.eada7340ba", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect event_id\nfrom \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__events\"\nwhere event_id is null\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:21.810364Z", "completed_at": "2024-09-10T15:31:21.814778Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:21.815005Z", "completed_at": "2024-09-10T15:31:21.815011Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.015363216400146484, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo.dbt_utils_unique_combination_of_columns_klaviyo__person_campaign_flow_person_id__last_touch_campaign_id__last_touch_flow_id__variation_id__source_relation.30e1824079", "compiled": true, "compiled_code": "\n\n\n\n\n\nwith validation_errors as (\n\n    select\n        person_id, last_touch_campaign_id, last_touch_flow_id, variation_id, source_relation\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__person_campaign_flow\"\n    group by person_id, last_touch_campaign_id, last_touch_flow_id, variation_id, source_relation\n    having count(*) > 1\n\n)\n\nselect *\nfrom validation_errors\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:21.806047Z", "completed_at": "2024-09-10T15:31:22.082410Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:22.082640Z", "completed_at": "2024-09-10T15:31:22.082645Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.3092329502105713, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo.int_klaviyo__person_metrics", "compiled": true, "compiled_code": "with person_campaign_flow as (\n\n    select *\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__person_campaign_flow\"\n),\n\nagg_metrics as (\n\n    select\n        person_id,\n        source_relation,\n        count(distinct last_touch_campaign_id) as count_total_campaigns,\n        count(distinct last_touch_flow_id) as count_total_flows,\n        min(first_event_at) as first_event_at, -- first ever event occurred at\n        max(last_event_at) as last_event_at, -- last ever event occurred at\n        min(distinct case when last_touch_campaign_id is not null then first_event_at end) as first_campaign_touch_at,\n        max(distinct case when last_touch_campaign_id is not null then last_event_at end) as last_campaign_touch_at,\n        min(distinct case when last_touch_flow_id is not null then first_event_at end) as first_flow_touch_at,\n        max(distinct case when last_touch_flow_id is not null then last_event_at end) as last_flow_touch_at\n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( sum_revenue_refunded_order ) as total_sum_revenue_refunded_order\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n        , sum( case when coalesce(last_touch_campaign_id, last_touch_flow_id) is null then sum_revenue_refunded_order else 0 end ) as organic_sum_revenue_refunded_order\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( sum_revenue_placed_order ) as total_sum_revenue_placed_order\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n        , sum( case when coalesce(last_touch_campaign_id, last_touch_flow_id) is null then sum_revenue_placed_order else 0 end ) as organic_sum_revenue_placed_order\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( sum_revenue_ordered_product ) as total_sum_revenue_ordered_product\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n        , sum( case when coalesce(last_touch_campaign_id, last_touch_flow_id) is null then sum_revenue_ordered_product else 0 end ) as organic_sum_revenue_ordered_product\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( sum_revenue_checkout_started ) as total_sum_revenue_checkout_started\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n        , sum( case when coalesce(last_touch_campaign_id, last_touch_flow_id) is null then sum_revenue_checkout_started else 0 end ) as organic_sum_revenue_checkout_started\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( sum_revenue_cancelled_order ) as total_sum_revenue_cancelled_order\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n        , sum( case when coalesce(last_touch_campaign_id, last_touch_flow_id) is null then sum_revenue_cancelled_order else 0 end ) as organic_sum_revenue_cancelled_order\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( count_active_on_site ) as total_count_active_on_site\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( count_viewed_product ) as total_count_viewed_product\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( count_ordered_product ) as total_count_ordered_product\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( count_placed_order ) as total_count_placed_order\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( count_refunded_order ) as total_count_refunded_order\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( count_received_email ) as total_count_received_email\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( count_clicked_email ) as total_count_clicked_email\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( count_opened_email ) as total_count_opened_email\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( count_marked_email_as_spam ) as total_count_marked_email_as_spam\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( count_unsubscribed ) as total_count_unsubscribed\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( count_received_sms ) as total_count_received_sms\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( count_clicked_sms ) as total_count_clicked_sms\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( count_sent_sms ) as total_count_sent_sms\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( count_unsubscribed_from_sms ) as total_count_unsubscribed_from_sms\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n\n        from person_campaign_flow\n    group by 1,2\n\n)\n\nselect * from agg_metrics", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"int_klaviyo__person_metrics\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:21.800566Z", "completed_at": "2024-09-10T15:31:22.090444Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:22.090643Z", "completed_at": "2024-09-10T15:31:22.090647Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 0.3509659767150879, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo.int_klaviyo__campaign_flow_metrics", "compiled": true, "compiled_code": "with person_campaign_flow as (\n\n    select *\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__person_campaign_flow\"\n),\n\n-- aggregating to the campaign/flow - variation level. so a flow with A/B versions will have 2 rows\nagg_metrics as (\n\n    select\n        last_touch_campaign_id,\n        last_touch_flow_id,\n        variation_id,\n        source_relation,\n        count(distinct person_id) as total_count_unique_people,\n        min(first_event_at) as first_event_at,\n        max(last_event_at) as last_event_at\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( sum_revenue_refunded_order ) as sum_revenue_refunded_order\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( sum_revenue_placed_order ) as sum_revenue_placed_order\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( sum_revenue_ordered_product ) as sum_revenue_ordered_product\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( sum_revenue_checkout_started ) as sum_revenue_checkout_started\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( sum_revenue_cancelled_order ) as sum_revenue_cancelled_order\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( count_active_on_site ) as count_active_on_site\n\n         -- only look at 'count' metrics for unique people counts\n        -- get unique number of people who did each kind of event\n        -- each record in person_campaign_flow is at the person-campaign/flow-variation level, \n        -- so we can just sum up 0s and 1s to get totals at the campaign/flow-variation grain.\n        , sum(case when count_active_on_site > 0 then 1 else 0 end) as unique_count_active_on_site\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( count_viewed_product ) as count_viewed_product\n\n         -- only look at 'count' metrics for unique people counts\n        -- get unique number of people who did each kind of event\n        -- each record in person_campaign_flow is at the person-campaign/flow-variation level, \n        -- so we can just sum up 0s and 1s to get totals at the campaign/flow-variation grain.\n        , sum(case when count_viewed_product > 0 then 1 else 0 end) as unique_count_viewed_product\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( count_ordered_product ) as count_ordered_product\n\n         -- only look at 'count' metrics for unique people counts\n        -- get unique number of people who did each kind of event\n        -- each record in person_campaign_flow is at the person-campaign/flow-variation level, \n        -- so we can just sum up 0s and 1s to get totals at the campaign/flow-variation grain.\n        , sum(case when count_ordered_product > 0 then 1 else 0 end) as unique_count_ordered_product\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( count_placed_order ) as count_placed_order\n\n         -- only look at 'count' metrics for unique people counts\n        -- get unique number of people who did each kind of event\n        -- each record in person_campaign_flow is at the person-campaign/flow-variation level, \n        -- so we can just sum up 0s and 1s to get totals at the campaign/flow-variation grain.\n        , sum(case when count_placed_order > 0 then 1 else 0 end) as unique_count_placed_order\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( count_refunded_order ) as count_refunded_order\n\n         -- only look at 'count' metrics for unique people counts\n        -- get unique number of people who did each kind of event\n        -- each record in person_campaign_flow is at the person-campaign/flow-variation level, \n        -- so we can just sum up 0s and 1s to get totals at the campaign/flow-variation grain.\n        , sum(case when count_refunded_order > 0 then 1 else 0 end) as unique_count_refunded_order\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( count_received_email ) as count_received_email\n\n         -- only look at 'count' metrics for unique people counts\n        -- get unique number of people who did each kind of event\n        -- each record in person_campaign_flow is at the person-campaign/flow-variation level, \n        -- so we can just sum up 0s and 1s to get totals at the campaign/flow-variation grain.\n        , sum(case when count_received_email > 0 then 1 else 0 end) as unique_count_received_email\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( count_clicked_email ) as count_clicked_email\n\n         -- only look at 'count' metrics for unique people counts\n        -- get unique number of people who did each kind of event\n        -- each record in person_campaign_flow is at the person-campaign/flow-variation level, \n        -- so we can just sum up 0s and 1s to get totals at the campaign/flow-variation grain.\n        , sum(case when count_clicked_email > 0 then 1 else 0 end) as unique_count_clicked_email\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( count_opened_email ) as count_opened_email\n\n         -- only look at 'count' metrics for unique people counts\n        -- get unique number of people who did each kind of event\n        -- each record in person_campaign_flow is at the person-campaign/flow-variation level, \n        -- so we can just sum up 0s and 1s to get totals at the campaign/flow-variation grain.\n        , sum(case when count_opened_email > 0 then 1 else 0 end) as unique_count_opened_email\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( count_marked_email_as_spam ) as count_marked_email_as_spam\n\n         -- only look at 'count' metrics for unique people counts\n        -- get unique number of people who did each kind of event\n        -- each record in person_campaign_flow is at the person-campaign/flow-variation level, \n        -- so we can just sum up 0s and 1s to get totals at the campaign/flow-variation grain.\n        , sum(case when count_marked_email_as_spam > 0 then 1 else 0 end) as unique_count_marked_email_as_spam\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( count_unsubscribed ) as count_unsubscribed\n\n         -- only look at 'count' metrics for unique people counts\n        -- get unique number of people who did each kind of event\n        -- each record in person_campaign_flow is at the person-campaign/flow-variation level, \n        -- so we can just sum up 0s and 1s to get totals at the campaign/flow-variation grain.\n        , sum(case when count_unsubscribed > 0 then 1 else 0 end) as unique_count_unsubscribed\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( count_received_sms ) as count_received_sms\n\n         -- only look at 'count' metrics for unique people counts\n        -- get unique number of people who did each kind of event\n        -- each record in person_campaign_flow is at the person-campaign/flow-variation level, \n        -- so we can just sum up 0s and 1s to get totals at the campaign/flow-variation grain.\n        , sum(case when count_received_sms > 0 then 1 else 0 end) as unique_count_received_sms\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( count_clicked_sms ) as count_clicked_sms\n\n         -- only look at 'count' metrics for unique people counts\n        -- get unique number of people who did each kind of event\n        -- each record in person_campaign_flow is at the person-campaign/flow-variation level, \n        -- so we can just sum up 0s and 1s to get totals at the campaign/flow-variation grain.\n        , sum(case when count_clicked_sms > 0 then 1 else 0 end) as unique_count_clicked_sms\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( count_sent_sms ) as count_sent_sms\n\n         -- only look at 'count' metrics for unique people counts\n        -- get unique number of people who did each kind of event\n        -- each record in person_campaign_flow is at the person-campaign/flow-variation level, \n        -- so we can just sum up 0s and 1s to get totals at the campaign/flow-variation grain.\n        , sum(case when count_sent_sms > 0 then 1 else 0 end) as unique_count_sent_sms\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( count_unsubscribed_from_sms ) as count_unsubscribed_from_sms\n\n         -- only look at 'count' metrics for unique people counts\n        -- get unique number of people who did each kind of event\n        -- each record in person_campaign_flow is at the person-campaign/flow-variation level, \n        -- so we can just sum up 0s and 1s to get totals at the campaign/flow-variation grain.\n        , sum(case when count_unsubscribed_from_sms > 0 then 1 else 0 end) as unique_count_unsubscribed_from_sms\n\n        \n        from person_campaign_flow\n    group by 1,2,3,4\n)\n\nselect * from agg_metrics", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"int_klaviyo__campaign_flow_metrics\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:22.147089Z", "completed_at": "2024-09-10T15:31:22.151298Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:22.152037Z", "completed_at": "2024-09-10T15:31:22.152042Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.03996109962463379, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo.dbt_utils_unique_combination_of_columns_int_klaviyo__person_metrics_person_id__source_relation.4897d57f8b", "compiled": true, "compiled_code": "\n\n\n\n\n\nwith validation_errors as (\n\n    select\n        person_id, source_relation\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"int_klaviyo__person_metrics\"\n    group by person_id, source_relation\n    having count(*) > 1\n\n)\n\nselect *\nfrom validation_errors\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:22.163177Z", "completed_at": "2024-09-10T15:31:22.165998Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:22.166210Z", "completed_at": "2024-09-10T15:31:22.166215Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.004354000091552734, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo.dbt_utils_unique_combination_of_columns_int_klaviyo__campaign_flow_metrics_variation_id__source_relation__last_touch_campaign_id__last_touch_flow_id.3ea05faa81", "compiled": true, "compiled_code": "\n\n\n\n\n\nwith validation_errors as (\n\n    select\n        variation_id, source_relation, last_touch_campaign_id, last_touch_flow_id\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"int_klaviyo__campaign_flow_metrics\"\n    group by variation_id, source_relation, last_touch_campaign_id, last_touch_flow_id\n    having count(*) > 1\n\n)\n\nselect *\nfrom validation_errors\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:22.112760Z", "completed_at": "2024-09-10T15:31:22.413295Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:22.413902Z", "completed_at": "2024-09-10T15:31:22.413916Z"}], "thread_id": "Thread-4 (worker)", "execution_time": 0.33316874504089355, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo.klaviyo__persons", "compiled": true, "compiled_code": "with person as (\n\n    select *\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__person\"\n),\n\nperson_metrics as (\n\n    select *\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"int_klaviyo__person_metrics\"\n),\n\nperson_join as (\n\n    select\n        person.*,\n        \"count_total_campaigns\",\n  \"count_total_flows\",\n  \"first_event_at\",\n  \"last_event_at\",\n  \"first_campaign_touch_at\",\n  \"last_campaign_touch_at\",\n  \"first_flow_touch_at\",\n  \"last_flow_touch_at\",\n  \"total_sum_revenue_refunded_order\",\n  \"organic_sum_revenue_refunded_order\",\n  \"total_sum_revenue_placed_order\",\n  \"organic_sum_revenue_placed_order\",\n  \"total_sum_revenue_ordered_product\",\n  \"organic_sum_revenue_ordered_product\",\n  \"total_sum_revenue_checkout_started\",\n  \"organic_sum_revenue_checkout_started\",\n  \"total_sum_revenue_cancelled_order\",\n  \"organic_sum_revenue_cancelled_order\",\n  \"total_count_active_on_site\",\n  \"total_count_viewed_product\",\n  \"total_count_ordered_product\",\n  \"total_count_placed_order\",\n  \"total_count_refunded_order\",\n  \"total_count_received_email\",\n  \"total_count_clicked_email\",\n  \"total_count_opened_email\",\n  \"total_count_marked_email_as_spam\",\n  \"total_count_unsubscribed\",\n  \"total_count_received_sms\",\n  \"total_count_clicked_sms\",\n  \"total_count_sent_sms\",\n  \"total_count_unsubscribed_from_sms\"\n\n    from person\n    left join person_metrics on (\n        person.person_id = person_metrics.person_id\n        and person.source_relation = person_metrics.source_relation\n    )\n\n)\n\nselect *\nfrom person_join", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__persons\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:22.447552Z", "completed_at": "2024-09-10T15:31:22.453805Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:22.454038Z", "completed_at": "2024-09-10T15:31:22.454044Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.006989002227783203, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo.dbt_utils_unique_combination_of_columns_klaviyo__persons_person_id__source_relation.b223d703b3", "compiled": true, "compiled_code": "\n\n\n\n\n\nwith validation_errors as (\n\n    select\n        person_id, source_relation\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__persons\"\n    group by person_id, source_relation\n    having count(*) > 1\n\n)\n\nselect *\nfrom validation_errors\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:22.451119Z", "completed_at": "2024-09-10T15:31:22.454476Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:22.454716Z", "completed_at": "2024-09-10T15:31:22.454720Z"}], "thread_id": "Thread-4 (worker)", "execution_time": 0.004110097885131836, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo.not_null_klaviyo__persons_person_id.624a41e75a", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect person_id\nfrom \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__persons\"\nwhere person_id is null\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:22.157348Z", "completed_at": "2024-09-10T15:31:22.507038Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:22.507298Z", "completed_at": "2024-09-10T15:31:22.507301Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 0.38263416290283203, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo.klaviyo__flows", "compiled": true, "compiled_code": "with flow as (\n\n    select *\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__flow\"\n),\n\nflow_metrics as (\n\n    select *\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"int_klaviyo__campaign_flow_metrics\"\n),\n\nflow_join as (\n    \n    \n\n    select\n        flow.*, -- has flow_id and source_relation\n        \"variation_id\",\n  \"total_count_unique_people\",\n  \"first_event_at\",\n  \"last_event_at\",\n  \"sum_revenue_refunded_order\",\n  \"sum_revenue_placed_order\",\n  \"sum_revenue_ordered_product\",\n  \"sum_revenue_checkout_started\",\n  \"sum_revenue_cancelled_order\",\n  \"count_active_on_site\",\n  \"unique_count_active_on_site\",\n  \"count_viewed_product\",\n  \"unique_count_viewed_product\",\n  \"count_ordered_product\",\n  \"unique_count_ordered_product\",\n  \"count_placed_order\",\n  \"unique_count_placed_order\",\n  \"count_refunded_order\",\n  \"unique_count_refunded_order\",\n  \"count_received_email\",\n  \"unique_count_received_email\",\n  \"count_clicked_email\",\n  \"unique_count_clicked_email\",\n  \"count_opened_email\",\n  \"unique_count_opened_email\",\n  \"count_marked_email_as_spam\",\n  \"unique_count_marked_email_as_spam\",\n  \"count_unsubscribed\",\n  \"unique_count_unsubscribed\",\n  \"count_received_sms\",\n  \"unique_count_received_sms\",\n  \"count_clicked_sms\",\n  \"unique_count_clicked_sms\",\n  \"count_sent_sms\",\n  \"unique_count_sent_sms\",\n  \"count_unsubscribed_from_sms\",\n  \"unique_count_unsubscribed_from_sms\"\n\n    from flow\n    left join flow_metrics on (\n      flow.flow_id = flow_metrics.last_touch_flow_id\n      and\n      flow.source_relation = flow_metrics.source_relation\n    )\n),\n\nfinal as (\n\n    select \n        *,\n        md5(cast(coalesce(cast(flow_id as TEXT), '_dbt_utils_surrogate_key_null_') || '-' || coalesce(cast(variation_id as TEXT), '_dbt_utils_surrogate_key_null_') as TEXT)) as flow_variation_key\n\n    from flow_join\n)\n\nselect *\nfrom final", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__flows\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:22.153013Z", "completed_at": "2024-09-10T15:31:22.506627Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:22.506845Z", "completed_at": "2024-09-10T15:31:22.506851Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.3860971927642822, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo.klaviyo__campaigns", "compiled": true, "compiled_code": "with campaign as (\n\n    select *\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__campaign\"\n),\n\ncampaign_metrics as (\n\n    select *\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"int_klaviyo__campaign_flow_metrics\"\n),\n\ncampaign_join as (\n    \n    \n\n    select\n        campaign.*, -- has campaign_id and source_relation\n        \"variation_id\",\n  \"total_count_unique_people\",\n  \"first_event_at\",\n  \"last_event_at\",\n  \"sum_revenue_refunded_order\",\n  \"sum_revenue_placed_order\",\n  \"sum_revenue_ordered_product\",\n  \"sum_revenue_checkout_started\",\n  \"sum_revenue_cancelled_order\",\n  \"count_active_on_site\",\n  \"unique_count_active_on_site\",\n  \"count_viewed_product\",\n  \"unique_count_viewed_product\",\n  \"count_ordered_product\",\n  \"unique_count_ordered_product\",\n  \"count_placed_order\",\n  \"unique_count_placed_order\",\n  \"count_refunded_order\",\n  \"unique_count_refunded_order\",\n  \"count_received_email\",\n  \"unique_count_received_email\",\n  \"count_clicked_email\",\n  \"unique_count_clicked_email\",\n  \"count_opened_email\",\n  \"unique_count_opened_email\",\n  \"count_marked_email_as_spam\",\n  \"unique_count_marked_email_as_spam\",\n  \"count_unsubscribed\",\n  \"unique_count_unsubscribed\",\n  \"count_received_sms\",\n  \"unique_count_received_sms\",\n  \"count_clicked_sms\",\n  \"unique_count_clicked_sms\",\n  \"count_sent_sms\",\n  \"unique_count_sent_sms\",\n  \"count_unsubscribed_from_sms\",\n  \"unique_count_unsubscribed_from_sms\"\n\n    from campaign\n    left join campaign_metrics on (\n      campaign.campaign_id = campaign_metrics.last_touch_campaign_id\n      and\n      campaign.source_relation = campaign_metrics.source_relation\n    )\n),\n\nfinal as (\n\n    select \n        *,\n        md5(cast(coalesce(cast(campaign_id as TEXT), '_dbt_utils_surrogate_key_null_') || '-' || coalesce(cast(variation_id as TEXT), '_dbt_utils_surrogate_key_null_') as TEXT)) as campaign_variation_key\n\n    from campaign_join\n)\n\nselect *\nfrom final", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__campaigns\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:22.539335Z", "completed_at": "2024-09-10T15:31:22.546677Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:22.549956Z", "completed_at": "2024-09-10T15:31:22.549961Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.012054920196533203, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo.dbt_utils_unique_combination_of_columns_klaviyo__flows_flow_variation_key__source_relation.925d4118dc", "compiled": true, "compiled_code": "\n\n\n\n\n\nwith validation_errors as (\n\n    select\n        flow_variation_key, source_relation\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__flows\"\n    group by flow_variation_key, source_relation\n    having count(*) > 1\n\n)\n\nselect *\nfrom validation_errors\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:22.543620Z", "completed_at": "2024-09-10T15:31:22.546883Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:22.550310Z", "completed_at": "2024-09-10T15:31:22.550313Z"}], "thread_id": "Thread-4 (worker)", "execution_time": 0.012151241302490234, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo.not_null_klaviyo__flows_flow_variation_key.152c0d960b", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect flow_variation_key\nfrom \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__flows\"\nwhere flow_variation_key is null\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:22.547246Z", "completed_at": "2024-09-10T15:31:22.553369Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:22.553608Z", "completed_at": "2024-09-10T15:31:22.553613Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 0.010298013687133789, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo.dbt_utils_unique_combination_of_columns_klaviyo__campaigns_campaign_variation_key__source_relation.e5d14aee28", "compiled": true, "compiled_code": "\n\n\n\n\n\nwith validation_errors as (\n\n    select\n        campaign_variation_key, source_relation\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__campaigns\"\n    group by campaign_variation_key, source_relation\n    having count(*) > 1\n\n)\n\nselect *\nfrom validation_errors\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-10T15:31:22.550634Z", "completed_at": "2024-09-10T15:31:22.554043Z"}, {"name": "execute", "started_at": "2024-09-10T15:31:22.554297Z", "completed_at": "2024-09-10T15:31:22.554301Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.008327007293701172, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo.not_null_klaviyo__campaigns_campaign_variation_key.c4588cdadc", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect campaign_variation_key\nfrom \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__campaigns\"\nwhere campaign_variation_key is null\n\n\n", "relation_name": null}], "elapsed_time": 3.084015130996704, "args": {"macro_debugging": false, "populate_cache": true, "warn_error_options": {"include": [], "exclude": []}, "invocation_command": "dbt docs generate -t postgres", "defer": false, "log_level": "info", "log_level_file": "debug", "partial_parse": true, "send_anonymous_usage_stats": true, "use_colors_file": true, "compile": true, "which": "generate", "use_colors": true, "strict_mode": false, "log_file_max_bytes": 10485760, "log_format": "default", "require_resource_names_without_spaces": false, "version_check": true, "profiles_dir": "/Users/joseph.markiewicz/.dbt", "enable_legacy_logger": false, "quiet": false, "source_freshness_run_project_hooks": false, "printer_width": 80, "empty_catalog": false, "indirect_selection": "eager", "log_format_file": "debug", "vars": {}, "cache_selected_only": false, "select": [], "show_resource_report": false, "project_dir": "/Users/joseph.markiewicz/Documents/dbt_packages/klaviyo/dbt_klaviyo/integration_tests", "static": false, "static_parser": true, "target": "postgres", "partial_parse_file_diff": true, "print": true, "introspect": true, "write_json": true, "log_path": "/Users/joseph.markiewicz/Documents/dbt_packages/klaviyo/dbt_klaviyo/integration_tests/logs", "require_explicit_package_overrides_for_builtin_materializations": true, "favor_state": false, "exclude": []}}