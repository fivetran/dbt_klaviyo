{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/run-results/v6.json", "dbt_version": "1.8.6", "generated_at": "2024-08-30T20:19:35.707483Z", "invocation_id": "9d37abef-055b-42da-aa4c-6471e90776af", "env": {}}, "results": [{"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:34.001009Z", "completed_at": "2024-08-30T20:19:34.029312Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:34.030128Z", "completed_at": "2024-08-30T20:19:34.030171Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.03153085708618164, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo_source.stg_klaviyo__campaign_tmp", "compiled": true, "compiled_code": "\n    \n    \n        \n        \n        \n        select * \n    from \"postgres\".\"klaviyo_integration_tests\".\"campaign\"", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__campaign_tmp\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:34.020940Z", "completed_at": "2024-08-30T20:19:34.029620Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:34.030958Z", "completed_at": "2024-08-30T20:19:34.030963Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 0.031915903091430664, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo_source.stg_klaviyo__event_tmp", "compiled": true, "compiled_code": "\n    \n    \n        \n        \n        \n        select * \n    from \"postgres\".\"klaviyo_integration_tests\".\"event\"", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__event_tmp\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:34.023999Z", "completed_at": "2024-08-30T20:19:34.029901Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:34.031353Z", "completed_at": "2024-08-30T20:19:34.031357Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.031987905502319336, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo_source.stg_klaviyo__flow_tmp", "compiled": true, "compiled_code": "\n    \n    \n        \n        \n        \n        select * \n    from \"postgres\".\"klaviyo_integration_tests\".\"flow\"", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__flow_tmp\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:34.026415Z", "completed_at": "2024-08-30T20:19:34.030641Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:34.032185Z", "completed_at": "2024-08-30T20:19:34.032188Z"}], "thread_id": "Thread-4 (worker)", "execution_time": 0.03248262405395508, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo_source.stg_klaviyo__metric_tmp", "compiled": true, "compiled_code": "\n    \n    \n        \n        \n        \n        select * \n    from \"postgres\".\"klaviyo_integration_tests\".\"metric\"", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__metric_tmp\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:34.039220Z", "completed_at": "2024-08-30T20:19:34.040398Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:34.044590Z", "completed_at": "2024-08-30T20:19:34.044599Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 0.010461807250976562, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.klaviyo_integration_tests.campaign", "compiled": null, "compiled_code": null, "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:34.040670Z", "completed_at": "2024-08-30T20:19:34.042623Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:34.045364Z", "completed_at": "2024-08-30T20:19:34.045378Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.010917901992797852, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.klaviyo_integration_tests.event", "compiled": null, "compiled_code": null, "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:34.043080Z", "completed_at": "2024-08-30T20:19:34.044236Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:34.045768Z", "completed_at": "2024-08-30T20:19:34.045772Z"}], "thread_id": "Thread-4 (worker)", "execution_time": 0.010608673095703125, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.klaviyo_integration_tests.flow", "compiled": null, "compiled_code": null, "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:34.036055Z", "completed_at": "2024-08-30T20:19:34.045030Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:34.046594Z", "completed_at": "2024-08-30T20:19:34.046601Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.013159990310668945, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo_source.stg_klaviyo__person_tmp", "compiled": true, "compiled_code": "\n    \n    \n        \n        \n        \n        select * \n    from \"postgres\".\"klaviyo_integration_tests\".\"person\"", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__person_tmp\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:34.049991Z", "completed_at": "2024-08-30T20:19:34.051197Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:34.063098Z", "completed_at": "2024-08-30T20:19:34.063107Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 0.015468120574951172, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.klaviyo_integration_tests.metric", "compiled": null, "compiled_code": null, "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:34.051825Z", "completed_at": "2024-08-30T20:19:34.052908Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:34.069845Z", "completed_at": "2024-08-30T20:19:34.069853Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.021691083908081055, "adapter_response": {}, "message": null, "failures": null, "unique_id": "seed.klaviyo_integration_tests.person", "compiled": null, "compiled_code": null, "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:34.053167Z", "completed_at": "2024-08-30T20:19:34.360963Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:34.366292Z", "completed_at": "2024-08-30T20:19:34.366301Z"}], "thread_id": "Thread-4 (worker)", "execution_time": 0.3459470272064209, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo_source.stg_klaviyo__campaign", "compiled": true, "compiled_code": "with base as (\n\n    select * \n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__campaign_tmp\"\n\n),\n\nfields as (\n\n    select\n        \n    \n    \n    _fivetran_deleted\n    \n as \n    \n    _fivetran_deleted\n    \n, \n    \n    \n    _fivetran_synced\n    \n as \n    \n    _fivetran_synced\n    \n, \n    \n    \n    campaign_type\n    \n as \n    \n    campaign_type\n    \n, \n    \n    \n    created\n    \n as \n    \n    created\n    \n, \n    \n    \n    email_template_id\n    \n as \n    \n    email_template_id\n    \n, \n    \n    \n    from_email\n    \n as \n    \n    from_email\n    \n, \n    \n    \n    from_name\n    \n as \n    \n    from_name\n    \n, \n    \n    \n    id\n    \n as \n    \n    id\n    \n, \n    \n    \n    name\n    \n as \n    \n    name\n    \n, \n    \n    \n    send_time\n    \n as \n    \n    send_time\n    \n, \n    \n    \n    sent_at\n    \n as \n    \n    sent_at\n    \n, \n    \n    \n    status\n    \n as \n    \n    status\n    \n, \n    \n    \n    status_id\n    \n as \n    \n    status_id\n    \n, \n    \n    \n    status_label\n    \n as \n    \n    status_label\n    \n, \n    \n    \n    subject\n    \n as \n    \n    subject\n    \n, \n    \n    \n    updated\n    \n as \n    \n    updated\n    \n, \n    \n    \n    archived\n    \n as \n    \n    archived\n    \n, \n    \n    \n    scheduled\n    \n as \n    \n    scheduled\n    \n\n\n\n        \n\n\n, cast('' as TEXT) as source_relation\n\n\n\n    from base\n),\n\nfinal as (\n    \n    select\n        campaign_type,\n        created as created_at,\n        email_template_id,\n        from_email,\n        from_name,\n        cast(id as TEXT ) as campaign_id,\n        name as campaign_name,\n        send_time as scheduled_to_send_at,\n        sent_at,\n        coalesce(status, lower(status_label)) as status,\n        status_id,\n        subject,\n        updated as updated_at,\n        archived as is_archived,\n        scheduled as scheduled_at,\n        source_relation\n\n    from fields\n\n    where not coalesce(_fivetran_deleted, false)\n)\n\nselect * from final", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__campaign\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:34.073765Z", "completed_at": "2024-08-30T20:19:34.365984Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:34.366716Z", "completed_at": "2024-08-30T20:19:34.366743Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 0.322969913482666, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo_source.stg_klaviyo__flow", "compiled": true, "compiled_code": "with base as (\n\n    select * \n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__flow_tmp\"\n\n),\n\nfields as (\n\n    select\n        \n    \n    \n    _fivetran_deleted\n    \n as \n    \n    _fivetran_deleted\n    \n, \n    \n    \n    _fivetran_synced\n    \n as \n    \n    _fivetran_synced\n    \n, \n    \n    \n    created\n    \n as \n    \n    created\n    \n, \n    \n    \n    id\n    \n as \n    \n    id\n    \n, \n    \n    \n    name\n    \n as \n    \n    name\n    \n, \n    \n    \n    status\n    \n as \n    \n    status\n    \n, \n    \n    \n    updated\n    \n as \n    \n    updated\n    \n, \n    \n    \n    archived\n    \n as \n    \n    archived\n    \n, \n    \n    \n    trigger_type\n    \n as \n    \n    trigger_type\n    \n\n\n\n        \n\n\n, cast('' as TEXT) as source_relation\n\n\n\n    from base\n),\n\nfinal as (\n    \n    select \n        created as created_at,\n        cast(id as TEXT ) as flow_id,\n        name as flow_name,\n        status,\n        updated as updated_at,\n        archived as is_archived,\n        trigger_type,\n        source_relation\n\n    from fields\n    where not coalesce(_fivetran_deleted, false)\n)\n\nselect * from final", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__flow\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:34.063579Z", "completed_at": "2024-08-30T20:19:34.366959Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:34.367656Z", "completed_at": "2024-08-30T20:19:34.367661Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.346250057220459, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo_source.stg_klaviyo__event", "compiled": true, "compiled_code": "with base as (\n\n    select * \n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__event_tmp\"\n\n),\n\nfields as (\n\n    select\n        \n    \n    \n    _fivetran_deleted\n    \n as \n    \n    _fivetran_deleted\n    \n, \n    \n    \n    _fivetran_synced\n    \n as \n    \n    _fivetran_synced\n    \n, \n    \n    \n    _variation\n    \n as \n    \n    _variation\n    \n, \n    \n    \n    campaign_id\n    \n as \n    \n    campaign_id\n    \n, \n    \n    \n    datetime\n    \n as \n    \n    datetime\n    \n, \n    \n    \n    flow_id\n    \n as \n    \n    flow_id\n    \n, \n    \n    \n    flow_message_id\n    \n as \n    \n    flow_message_id\n    \n, \n    \n    \n    id\n    \n as \n    \n    id\n    \n, \n    \n    \n    metric_id\n    \n as \n    \n    metric_id\n    \n, \n    \n    \n    person_id\n    \n as \n    \n    person_id\n    \n, \n    \n    \n    timestamp\n    \n as \n    \n    timestamp\n    \n, \n    \n    \n    type\n    \n as \n    \n    type\n    \n, \n    \n    \n    uuid\n    \n as \n    \n    uuid\n    \n, \n    \n    \n    property_value\n    \n as \n    \n    property_value\n    \n\n\n\n        \n\n\n, cast('' as TEXT) as source_relation\n\n\n\n    from base\n),\n\nrename as (\n    \n    select \n        _variation as variation_id,\n        cast(campaign_id as TEXT ) as campaign_id,\n        cast(timestamp as timestamp ) as occurred_at,\n        cast(flow_id as TEXT ) as flow_id,\n        flow_message_id,\n        cast(id as TEXT ) as event_id,\n        cast(metric_id as TEXT ) as metric_id,\n        cast(person_id as TEXT ) as person_id,\n        type,\n        uuid,\n        \n\n    cast(regexp_replace(cast(property_value as TEXT), '[^0-9.]*', '', 'g') as numeric(28,6))\n\n as numeric_value,\n        cast(_fivetran_synced as timestamp ) as _fivetran_synced,\n        source_relation\n        \n\n\n\n\n\n    from fields\n    where not coalesce(_fivetran_deleted, false)\n),\n\nfinal as (\n    \n    select \n        *,\n        cast( date_trunc('day', occurred_at) as date) as occurred_on,\n        md5(cast(coalesce(cast(event_id as TEXT), '_dbt_utils_surrogate_key_null_') || '-' || coalesce(cast(source_relation as TEXT), '_dbt_utils_surrogate_key_null_') as TEXT)) as unique_event_id\n\n    from rename\n\n)\n\nselect * from final", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__event\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:34.077926Z", "completed_at": "2024-08-30T20:19:34.367335Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:34.367955Z", "completed_at": "2024-08-30T20:19:34.367960Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.3231360912322998, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo_source.stg_klaviyo__metric", "compiled": true, "compiled_code": "with base as (\n\n    select * \n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__metric_tmp\"\n\n),\n\nfields as (\n\n    select\n        \n    \n    \n    _fivetran_deleted\n    \n as \n    \n    _fivetran_deleted\n    \n, \n    \n    \n    _fivetran_synced\n    \n as \n    \n    _fivetran_synced\n    \n, \n    \n    \n    created\n    \n as \n    \n    created\n    \n, \n    \n    \n    id\n    \n as \n    \n    id\n    \n, \n    \n    \n    integration_id\n    \n as \n    \n    integration_id\n    \n, \n    \n    \n    integration_category\n    \n as \n    \n    integration_category\n    \n, \n    \n    \n    integration_name\n    \n as \n    \n    integration_name\n    \n, \n    \n    \n    name\n    \n as \n    \n    name\n    \n, \n    \n    \n    updated\n    \n as \n    \n    updated\n    \n\n\n\n        \n\n\n, cast('' as TEXT) as source_relation\n\n\n\n    from base\n),\n\nfinal as (\n    \n    select \n        created as created_at,\n        cast(id as TEXT ) as metric_id,\n        cast(integration_id as TEXT ) as integration_id,\n        integration_name,\n        integration_category,\n        name as metric_name,\n        updated as updated_at,\n        source_relation\n\n    from fields\n\n    where not coalesce(_fivetran_deleted, false)\n)\n\nselect * from final", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__metric\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:34.412695Z", "completed_at": "2024-08-30T20:19:34.421928Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:34.423045Z", "completed_at": "2024-08-30T20:19:34.423054Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.024216175079345703, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo_source.not_null_stg_klaviyo__campaign_campaign_id.5dfc47dc1d", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect campaign_id\nfrom \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__campaign\"\nwhere campaign_id is null\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:34.417486Z", "completed_at": "2024-08-30T20:19:34.422380Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:34.423664Z", "completed_at": "2024-08-30T20:19:34.423669Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.024498939514160156, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo_source.dbt_utils_unique_combination_of_columns_stg_klaviyo__flow_flow_id__source_relation.015215d481", "compiled": true, "compiled_code": "\n\n\n\n\n\nwith validation_errors as (\n\n    select\n        flow_id, source_relation\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__flow\"\n    group by flow_id, source_relation\n    having count(*) > 1\n\n)\n\nselect *\nfrom validation_errors\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:34.404866Z", "completed_at": "2024-08-30T20:19:34.422669Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:34.424169Z", "completed_at": "2024-08-30T20:19:34.424188Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 0.025627851486206055, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo_source.dbt_utils_unique_combination_of_columns_stg_klaviyo__campaign_campaign_id__source_relation.59158488ff", "compiled": true, "compiled_code": "\n\n\n\n\n\nwith validation_errors as (\n\n    select\n        campaign_id, source_relation\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__campaign\"\n    group by campaign_id, source_relation\n    having count(*) > 1\n\n)\n\nselect *\nfrom validation_errors\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:34.427505Z", "completed_at": "2024-08-30T20:19:34.449281Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:34.449655Z", "completed_at": "2024-08-30T20:19:34.449666Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.024142980575561523, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo_source.not_null_stg_klaviyo__flow_flow_id.a00a897e42", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect flow_id\nfrom \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__flow\"\nwhere flow_id is null\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:34.430278Z", "completed_at": "2024-08-30T20:19:34.450111Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:34.452546Z", "completed_at": "2024-08-30T20:19:34.452551Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.02666306495666504, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo.int_klaviyo__event_attribution", "compiled": true, "compiled_code": "\n\nwith events as (\n\n    select \n        *,\n        -- no event will be attributed to both a campaign and flow\n        coalesce(campaign_id, flow_id) as touch_id,\n        case \n            when campaign_id is not null then 'campaign' \n            when flow_id is not null then 'flow' \n        else null end as touch_type -- defintion: touch = interaction with campaign/flow\n\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__event\"\n\n    \n    -- grab **ALL** events for users who have any events in this new increment\n    where person_id in (\n\n        select distinct person_id\n        from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__event\"\n\n        -- most events (from all kinds of integrations) at least once every hour\n        -- https://help.klaviyo.com/hc/en-us/articles/115005253208\n        where _fivetran_synced >= cast(coalesce( \n            (\n                select \n\n    max(_fivetran_synced) + ((interval '1 hour') * (-1))\n\n  \n                from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"int_klaviyo__event_attribution\"\n            ), '2012-01-01') as timestamp ) -- klaviyo was founded in 2012, so let's default the min date to then\n    )\n    \n),\n\n-- sessionize events based on attribution eligibility -- is it the right kind of event, and does it have a campaign or flow?\ncreate_sessions as (\n    select\n        *,\n        -- default klaviyo__event_attribution_filter limits attribution-eligible events to to email opens, email clicks, and sms opens\n        -- https://help.klaviyo.com/hc/en-us/articles/115005248128\n\n        -- events that come with flow/campaign attributions (and are eligible event types) will create new sessions.\n        -- non-attributed events that come in afterward will be batched into the same attribution-session\n        sum(case when touch_id is not null\n        \n            and lower(type) in ('opened email', 'clicked email', 'clicked sms')\n        \n            then 1 else 0 end) over (\n                partition by person_id, source_relation order by occurred_at asc rows between unbounded preceding and current row) as touch_session \n\n    from events\n\n),\n\n-- \"session start\" refers to the event in a \"touch session\" that is already attributed with a campaign or flow by Klaviyo\n-- a new event that is attributed with a campaign/flow will trigger a new session, so there will only be one already-attributed event per each session \n-- events that are missing attributions will borrow data from the event that triggered the session, if they are in the lookback window (see `attribute` CTE)\nlast_touches as (\n\n    select \n        *,\n        -- when did the touch session begin?\n        min(occurred_at) over(partition by person_id, source_relation, touch_session) as session_start_at,\n\n        -- get the kind of metric/event that triggered the attribution session, in order to decide \n        -- to use the sms or email lookback value. \n        first_value(type) over(\n            partition by person_id, source_relation, touch_session order by occurred_at asc rows between unbounded preceding and current row) as session_event_type\n\n    from create_sessions\n),\n\nattribute as (\n\n    select \n        *,\n        -- klaviyo uses different lookback windows for email and sms events\n        -- default email lookback = 5 days (120 hours) -> https://help.klaviyo.com/hc/en-us/articles/115005248128#conversion-tracking1\n        -- default sms lookback: 1 day (24 hours -> https://help.klaviyo.com/hc/en-us/articles/115005248128#sms-conversion-tracking7\n\n        coalesce(touch_id, -- use pre-attributed flow/campaign if provided\n            case \n            when \n        (\n        ((occurred_at)::date - (session_start_at)::date)\n     * 24 + date_part('hour', (occurred_at)::timestamp) - date_part('hour', (session_start_at)::timestamp))\n     <= (\n                case \n                when lower(session_event_type) like '%sms%' then 24\n                else 120 end\n            ) -- if the events fall within the lookback window, attribute\n            then first_value(touch_id) over (\n                partition by person_id, source_relation, touch_session order by occurred_at asc rows between unbounded preceding and current row)\n            else null end) as last_touch_id -- session qualified for attribution -> we will call this \"last touch\"\n\n    from last_touches \n),\n\nfinal as (\n\n    select\n        *,\n\n        -- get whether the event is attributed to a flow or campaign\n        coalesce(touch_type, first_value(touch_type) over(\n            partition by person_id, source_relation, touch_session order by occurred_at asc rows between unbounded preceding and current row)) \n\n            as session_touch_type -- if the session events qualified for attribution, extract the type of touch they are attributed to\n\n    from attribute \n)\n\nselect * from final", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"int_klaviyo__event_attribution\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:34.445248Z", "completed_at": "2024-08-30T20:19:34.451858Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:34.452956Z", "completed_at": "2024-08-30T20:19:34.452959Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 0.02675628662109375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo_source.dbt_utils_unique_combination_of_columns_stg_klaviyo__event_event_id__source_relation.3778c651d7", "compiled": true, "compiled_code": "\n\n\n\n\n\nwith validation_errors as (\n\n    select\n        event_id, source_relation\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__event\"\n    group by event_id, source_relation\n    having count(*) > 1\n\n)\n\nselect *\nfrom validation_errors\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:34.455388Z", "completed_at": "2024-08-30T20:19:34.465055Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:34.465607Z", "completed_at": "2024-08-30T20:19:34.465616Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.012359857559204102, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo_source.not_null_stg_klaviyo__event_event_id.7a09ac6ec1", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect event_id\nfrom \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__event\"\nwhere event_id is null\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:34.458839Z", "completed_at": "2024-08-30T20:19:34.466034Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:34.466992Z", "completed_at": "2024-08-30T20:19:34.466998Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.012312889099121094, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo_source.dbt_utils_unique_combination_of_columns_stg_klaviyo__metric_metric_id__source_relation.e9f33c04e5", "compiled": true, "compiled_code": "\n\n\n\n\n\nwith validation_errors as (\n\n    select\n        metric_id, source_relation\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__metric\"\n    group by metric_id, source_relation\n    having count(*) > 1\n\n)\n\nselect *\nfrom validation_errors\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:34.462532Z", "completed_at": "2024-08-30T20:19:34.466702Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:34.467681Z", "completed_at": "2024-08-30T20:19:34.467685Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 0.012655973434448242, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo_source.not_null_stg_klaviyo__metric_metric_id.4759d62078", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect metric_id\nfrom \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__metric\"\nwhere metric_id is null\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:34.469099Z", "completed_at": "2024-08-30T20:19:34.474873Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:34.475164Z", "completed_at": "2024-08-30T20:19:34.475176Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.007875680923461914, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo.dbt_utils_unique_combination_of_columns_int_klaviyo__event_attribution_event_id__source_relation.654b98ad2c", "compiled": true, "compiled_code": "\n\n\n\n\n\nwith validation_errors as (\n\n    select\n        event_id, source_relation\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"int_klaviyo__event_attribution\"\n    group by event_id, source_relation\n    having count(*) > 1\n\n)\n\nselect *\nfrom validation_errors\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:34.472216Z", "completed_at": "2024-08-30T20:19:34.475685Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:34.476052Z", "completed_at": "2024-08-30T20:19:34.476056Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.007359027862548828, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo.not_null_int_klaviyo__event_attribution_event_id.8d186152c4", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect event_id\nfrom \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"int_klaviyo__event_attribution\"\nwhere event_id is null\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:34.400613Z", "completed_at": "2024-08-30T20:19:34.679441Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:34.679715Z", "completed_at": "2024-08-30T20:19:34.679721Z"}], "thread_id": "Thread-4 (worker)", "execution_time": 0.3075132369995117, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo_source.stg_klaviyo__person", "compiled": true, "compiled_code": "with base as (\n\n    select * \n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__person_tmp\"\n\n),\n\nfields as (\n\n    select\n        \n    \n    \n    _fivetran_deleted\n    \n as \n    \n    _fivetran_deleted\n    \n, \n    \n    \n    _fivetran_synced\n    \n as \n    \n    _fivetran_synced\n    \n, \n    \n    \n    address_1\n    \n as \n    \n    address_1\n    \n, \n    \n    \n    address_2\n    \n as \n    \n    address_2\n    \n, \n    \n    \n    city\n    \n as \n    \n    city\n    \n, \n    \n    \n    country\n    \n as \n    \n    country\n    \n, \n    \n    \n    created\n    \n as \n    \n    created\n    \n, \n    \n    \n    email\n    \n as \n    \n    email\n    \n, \n    \n    \n    first_name\n    \n as \n    \n    first_name\n    \n, \n    \n    \n    id\n    \n as \n    \n    id\n    \n, \n    \n    \n    last_name\n    \n as \n    \n    last_name\n    \n, \n    \n    \n    latitude\n    \n as \n    \n    latitude\n    \n, \n    \n    \n    longitude\n    \n as \n    \n    longitude\n    \n, \n    \n    \n    organization\n    \n as \n    \n    organization\n    \n, \n    \n    \n    phone_number\n    \n as \n    \n    phone_number\n    \n, \n    \n    \n    region\n    \n as \n    \n    region\n    \n, \n    \n    \n    timezone\n    \n as \n    \n    timezone\n    \n, \n    \n    \n    title\n    \n as \n    \n    title\n    \n, \n    \n    \n    updated\n    \n as \n    \n    updated\n    \n, \n    \n    \n    zip\n    \n as \n    \n    zip\n    \n, \n    \n    \n    last_event_date\n    \n as \n    \n    last_event_date\n    \n\n\n\n        \n\n\n, cast('' as TEXT) as source_relation\n\n\n\n    from base\n),\n\nfinal as (\n    \n    select \n        cast(id as TEXT ) as person_id,\n        address_1,\n        address_2,\n        city,\n        country,\n        zip,\n        created as created_at,\n        email,\n        first_name || ' ' || last_name as full_name,\n        latitude,\n        longitude,\n        organization,\n        phone_number,\n        region, -- state in USA\n        timezone,\n        title,\n        updated as updated_at,\n        last_event_date,\n        source_relation\n        \n        \n\n\n\n\n\n    from fields\n    where not coalesce(_fivetran_deleted, false)\n)\n\nselect * from final", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__person\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:34.713087Z", "completed_at": "2024-08-30T20:19:34.734108Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:34.734824Z", "completed_at": "2024-08-30T20:19:34.734835Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.027366161346435547, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo_source.not_null_stg_klaviyo__person_person_id.bd77ffc8aa", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect person_id\nfrom \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__person\"\nwhere person_id is null\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:34.709052Z", "completed_at": "2024-08-30T20:19:34.734406Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:34.735337Z", "completed_at": "2024-08-30T20:19:34.735344Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 0.028456926345825195, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo_source.dbt_utils_unique_combination_of_columns_stg_klaviyo__person_person_id__source_relation.33a4f9ca24", "compiled": true, "compiled_code": "\n\n\n\n\n\nwith validation_errors as (\n\n    select\n        person_id, source_relation\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__person\"\n    group by person_id, source_relation\n    having count(*) > 1\n\n)\n\nselect *\nfrom validation_errors\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:34.715719Z", "completed_at": "2024-08-30T20:19:34.979710Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:34.979951Z", "completed_at": "2024-08-30T20:19:34.979957Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.3028099536895752, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo.klaviyo__events", "compiled": true, "compiled_code": "\n-- ^ the incremental strategy is split into delete+insert for snowflake since there is a bit of\n-- overlap in transformed data blocks for incremental runs (we look back an extra hour, see lines 23 - 30)\n-- this configuration solution was taken from https://docs.getdbt.com/reference/resource-configs/snowflake-configs#merge-behavior-incremental-models\n\nwith events as (\n\n    select *\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"int_klaviyo__event_attribution\"\n\n    \n\n    -- most events (from all kinds of integrations) at least once every hour\n    where _fivetran_synced >= cast(coalesce( \n            (\n                select \n\n    max(_fivetran_synced) + ((interval '1 hour') * (-1))\n\n  \n                from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__events\"\n            ), '2012-01-01') as timestamp ) -- klaviyo was founded in 2012, so let's default the min date to then\n    \n),\n\nevent_fields as (\n\n    -- excluding some fields to rename them and/or make them null if needed\n    \n    -- as of the patch release of dbt-utils v0.7.3, the snowflake uppercasing is not needed anymore so we have deleted the snowflake conditional in the exclusion\n\n    select \n        \"variation_id\",\n  \"campaign_id\",\n  \"occurred_at\",\n  \"flow_id\",\n  \"flow_message_id\",\n  \"event_id\",\n  \"metric_id\",\n  \"person_id\",\n  \"uuid\",\n  \"numeric_value\",\n  \"_fivetran_synced\",\n  \"source_relation\",\n  \"occurred_on\",\n  \"unique_event_id\",\n  \"touch_id\",\n  \"touch_type\",\n\n        type, -- need to pull this out because it gets removed by dbt_utils.star, due to being a substring of 'session_event_type' and 'session_touch_type'\n\n        -- split out campaign and flow IDs\n        case \n            when session_touch_type = 'campaign' then last_touch_id \n        else null end as last_touch_campaign_id,\n        case \n            when session_touch_type = 'flow' then last_touch_id \n        else null end as last_touch_flow_id,\n\n        -- only make these non-null if the event indeed qualified for attribution\n        case \n            when last_touch_id is not null then session_start_at \n        else null end as last_touch_at,\n        case \n            when last_touch_id is not null then session_event_type \n        else null end as last_touch_event_type,\n        case \n            when last_touch_id is not null then session_touch_type \n        else null end as last_touch_type -- flow vs campaign\n\n    \n    from events\n),\n\ncampaign as (\n\n    select *\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__campaign\"\n),\n\nflow as (\n\n    select *\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__flow\"\n),\n\nperson as (\n\n    select *\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__person\"\n),\n\n-- just pulling this to join with INTEGRATION\nmetric as (\n\n    select *\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__metric\"\n),\n\njoin_fields as (\n\n    select\n        event_fields.*,\n        campaign.campaign_name,\n        campaign.campaign_type,\n        campaign.subject as campaign_subject_line,\n        flow.flow_name, \n        person.city as person_city,\n        person.country as person_country,\n        person.region as person_region,\n        person.email as person_email,\n        person.timezone as person_timezone,\n        metric.integration_id,\n        metric.integration_name,\n        metric.integration_category\n\n    from event_fields\n    left join campaign on (\n      event_fields.last_touch_campaign_id = campaign.campaign_id\n      and\n      event_fields.source_relation = campaign.source_relation\n    )\n    left join flow on (\n      event_fields.last_touch_flow_id = flow.flow_id\n      and\n      event_fields.source_relation = flow.source_relation  \n    )\n    left join person on (\n      event_fields.person_id = person.person_id\n      and\n      event_fields.source_relation = person.source_relation\n    )\n    left join metric on (\n      event_fields.metric_id = metric.metric_id\n      and\n      event_fields.source_relation = metric.source_relation\n    )\n)\n\nselect * from join_fields", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__events\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:35.014856Z", "completed_at": "2024-08-30T20:19:35.029430Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:35.030349Z", "completed_at": "2024-08-30T20:19:35.030360Z"}], "thread_id": "Thread-4 (worker)", "execution_time": 0.017322063446044922, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo.klaviyo__person_campaign_flow", "compiled": true, "compiled_code": "with events as (\n    select *\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__events\"\n),\n\npivot_out_events as (\n    \n    select \n        person_id,\n        last_touch_campaign_id,\n        last_touch_flow_id,\n        campaign_name,\n        flow_name,\n        variation_id,\n        source_relation,\n        min(occurred_at) as first_event_at,\n        max(occurred_at) as last_event_at\n\n    -- sum up the numeric value associated with events (most likely will mean revenue)\n    \n    , sum(case when lower(type) = 'refunded order' then \n            coalesce(\n    case\n        when replace(cast(numeric_value as varchar),cast(' ' as varchar),cast('' as varchar)) ~ '^(0|[1-9][0-9]*)$' \n        then replace(cast(numeric_value as varchar),cast(' ' as varchar),cast('' as varchar))\n        else null\n    end::numeric\n\n\n\n, 0)\n            else 0 end) \n        as sum_revenue_refunded_order -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'placed order' then \n            coalesce(\n    case\n        when replace(cast(numeric_value as varchar),cast(' ' as varchar),cast('' as varchar)) ~ '^(0|[1-9][0-9]*)$' \n        then replace(cast(numeric_value as varchar),cast(' ' as varchar),cast('' as varchar))\n        else null\n    end::numeric\n\n\n\n, 0)\n            else 0 end) \n        as sum_revenue_placed_order -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'ordered product' then \n            coalesce(\n    case\n        when replace(cast(numeric_value as varchar),cast(' ' as varchar),cast('' as varchar)) ~ '^(0|[1-9][0-9]*)$' \n        then replace(cast(numeric_value as varchar),cast(' ' as varchar),cast('' as varchar))\n        else null\n    end::numeric\n\n\n\n, 0)\n            else 0 end) \n        as sum_revenue_ordered_product -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'checkout started' then \n            coalesce(\n    case\n        when replace(cast(numeric_value as varchar),cast(' ' as varchar),cast('' as varchar)) ~ '^(0|[1-9][0-9]*)$' \n        then replace(cast(numeric_value as varchar),cast(' ' as varchar),cast('' as varchar))\n        else null\n    end::numeric\n\n\n\n, 0)\n            else 0 end) \n        as sum_revenue_checkout_started -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'cancelled order' then \n            coalesce(\n    case\n        when replace(cast(numeric_value as varchar),cast(' ' as varchar),cast('' as varchar)) ~ '^(0|[1-9][0-9]*)$' \n        then replace(cast(numeric_value as varchar),cast(' ' as varchar),cast('' as varchar))\n        else null\n    end::numeric\n\n\n\n, 0)\n            else 0 end) \n        as sum_revenue_cancelled_order -- removing special characters that I have seen in different integration events\n    \n\n    -- count up the number of instances of each metric\n    \n    , sum(case when lower(type) = 'active on site' then 1 else 0 end) \n        as count_active_on_site -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'viewed product' then 1 else 0 end) \n        as count_viewed_product -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'ordered product' then 1 else 0 end) \n        as count_ordered_product -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'placed order' then 1 else 0 end) \n        as count_placed_order -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'refunded order' then 1 else 0 end) \n        as count_refunded_order -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'received email' then 1 else 0 end) \n        as count_received_email -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'clicked email' then 1 else 0 end) \n        as count_clicked_email -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'opened email' then 1 else 0 end) \n        as count_opened_email -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'marked email as spam' then 1 else 0 end) \n        as count_marked_email_as_spam -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'unsubscribed' then 1 else 0 end) \n        as count_unsubscribed -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'received sms' then 1 else 0 end) \n        as count_received_sms -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'clicked sms' then 1 else 0 end) \n        as count_clicked_sms -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'sent sms' then 1 else 0 end) \n        as count_sent_sms -- removing special characters that I have seen in different integration events\n    \n    , sum(case when lower(type) = 'unsubscribed from sms' then 1 else 0 end) \n        as count_unsubscribed_from_sms -- removing special characters that I have seen in different integration events\n    \n\n    from events\n    group by 1,2,3,4,5,6,7\n)\n\nselect *\nfrom pivot_out_events", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__person_campaign_flow\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:35.023781Z", "completed_at": "2024-08-30T20:19:35.029760Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:35.030867Z", "completed_at": "2024-08-30T20:19:35.030871Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.01742696762084961, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo.dbt_utils_unique_combination_of_columns_klaviyo__events_event_id__source_relation.847dad4174", "compiled": true, "compiled_code": "\n\n\n\n\n\nwith validation_errors as (\n\n    select\n        event_id, source_relation\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__events\"\n    group by event_id, source_relation\n    having count(*) > 1\n\n)\n\nselect *\nfrom validation_errors\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:35.026622Z", "completed_at": "2024-08-30T20:19:35.030051Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:35.031264Z", "completed_at": "2024-08-30T20:19:35.031268Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 0.017484188079833984, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo.not_null_klaviyo__events_event_id.eada7340ba", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect event_id\nfrom \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__events\"\nwhere event_id is null\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:35.079826Z", "completed_at": "2024-08-30T20:19:35.084652Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:35.084980Z", "completed_at": "2024-08-30T20:19:35.084989Z"}], "thread_id": "Thread-4 (worker)", "execution_time": 0.05157899856567383, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo.dbt_utils_unique_combination_of_columns_klaviyo__person_campaign_flow_person_id__last_touch_campaign_id__last_touch_flow_id__variation_id__source_relation.30e1824079", "compiled": true, "compiled_code": "\n\n\n\n\n\nwith validation_errors as (\n\n    select\n        person_id, last_touch_campaign_id, last_touch_flow_id, variation_id, source_relation\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__person_campaign_flow\"\n    group by person_id, last_touch_campaign_id, last_touch_flow_id, variation_id, source_relation\n    having count(*) > 1\n\n)\n\nselect *\nfrom validation_errors\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:35.034571Z", "completed_at": "2024-08-30T20:19:35.331956Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:35.332175Z", "completed_at": "2024-08-30T20:19:35.332181Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.3224349021911621, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo.int_klaviyo__campaign_flow_metrics", "compiled": true, "compiled_code": "with person_campaign_flow as (\n\n    select *\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__person_campaign_flow\"\n),\n\n-- aggregating to the campaign/flow - variation level. so a flow with A/B versions will have 2 rows\nagg_metrics as (\n\n    select\n        last_touch_campaign_id,\n        last_touch_flow_id,\n        variation_id,\n        source_relation,\n        count(distinct person_id) as total_count_unique_people,\n        min(first_event_at) as first_event_at,\n        max(last_event_at) as last_event_at\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( sum_revenue_refunded_order ) as sum_revenue_refunded_order\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( sum_revenue_placed_order ) as sum_revenue_placed_order\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( sum_revenue_ordered_product ) as sum_revenue_ordered_product\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( sum_revenue_checkout_started ) as sum_revenue_checkout_started\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( sum_revenue_cancelled_order ) as sum_revenue_cancelled_order\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( count_active_on_site ) as count_active_on_site\n\n         -- only look at 'count' metrics for unique people counts\n        -- get unique number of people who did each kind of event\n        -- each record in person_campaign_flow is at the person-campaign/flow-variation level, \n        -- so we can just sum up 0s and 1s to get totals at the campaign/flow-variation grain.\n        , sum(case when count_active_on_site > 0 then 1 else 0 end) as unique_count_active_on_site\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( count_viewed_product ) as count_viewed_product\n\n         -- only look at 'count' metrics for unique people counts\n        -- get unique number of people who did each kind of event\n        -- each record in person_campaign_flow is at the person-campaign/flow-variation level, \n        -- so we can just sum up 0s and 1s to get totals at the campaign/flow-variation grain.\n        , sum(case when count_viewed_product > 0 then 1 else 0 end) as unique_count_viewed_product\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( count_ordered_product ) as count_ordered_product\n\n         -- only look at 'count' metrics for unique people counts\n        -- get unique number of people who did each kind of event\n        -- each record in person_campaign_flow is at the person-campaign/flow-variation level, \n        -- so we can just sum up 0s and 1s to get totals at the campaign/flow-variation grain.\n        , sum(case when count_ordered_product > 0 then 1 else 0 end) as unique_count_ordered_product\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( count_placed_order ) as count_placed_order\n\n         -- only look at 'count' metrics for unique people counts\n        -- get unique number of people who did each kind of event\n        -- each record in person_campaign_flow is at the person-campaign/flow-variation level, \n        -- so we can just sum up 0s and 1s to get totals at the campaign/flow-variation grain.\n        , sum(case when count_placed_order > 0 then 1 else 0 end) as unique_count_placed_order\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( count_refunded_order ) as count_refunded_order\n\n         -- only look at 'count' metrics for unique people counts\n        -- get unique number of people who did each kind of event\n        -- each record in person_campaign_flow is at the person-campaign/flow-variation level, \n        -- so we can just sum up 0s and 1s to get totals at the campaign/flow-variation grain.\n        , sum(case when count_refunded_order > 0 then 1 else 0 end) as unique_count_refunded_order\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( count_received_email ) as count_received_email\n\n         -- only look at 'count' metrics for unique people counts\n        -- get unique number of people who did each kind of event\n        -- each record in person_campaign_flow is at the person-campaign/flow-variation level, \n        -- so we can just sum up 0s and 1s to get totals at the campaign/flow-variation grain.\n        , sum(case when count_received_email > 0 then 1 else 0 end) as unique_count_received_email\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( count_clicked_email ) as count_clicked_email\n\n         -- only look at 'count' metrics for unique people counts\n        -- get unique number of people who did each kind of event\n        -- each record in person_campaign_flow is at the person-campaign/flow-variation level, \n        -- so we can just sum up 0s and 1s to get totals at the campaign/flow-variation grain.\n        , sum(case when count_clicked_email > 0 then 1 else 0 end) as unique_count_clicked_email\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( count_opened_email ) as count_opened_email\n\n         -- only look at 'count' metrics for unique people counts\n        -- get unique number of people who did each kind of event\n        -- each record in person_campaign_flow is at the person-campaign/flow-variation level, \n        -- so we can just sum up 0s and 1s to get totals at the campaign/flow-variation grain.\n        , sum(case when count_opened_email > 0 then 1 else 0 end) as unique_count_opened_email\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( count_marked_email_as_spam ) as count_marked_email_as_spam\n\n         -- only look at 'count' metrics for unique people counts\n        -- get unique number of people who did each kind of event\n        -- each record in person_campaign_flow is at the person-campaign/flow-variation level, \n        -- so we can just sum up 0s and 1s to get totals at the campaign/flow-variation grain.\n        , sum(case when count_marked_email_as_spam > 0 then 1 else 0 end) as unique_count_marked_email_as_spam\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( count_unsubscribed ) as count_unsubscribed\n\n         -- only look at 'count' metrics for unique people counts\n        -- get unique number of people who did each kind of event\n        -- each record in person_campaign_flow is at the person-campaign/flow-variation level, \n        -- so we can just sum up 0s and 1s to get totals at the campaign/flow-variation grain.\n        , sum(case when count_unsubscribed > 0 then 1 else 0 end) as unique_count_unsubscribed\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( count_received_sms ) as count_received_sms\n\n         -- only look at 'count' metrics for unique people counts\n        -- get unique number of people who did each kind of event\n        -- each record in person_campaign_flow is at the person-campaign/flow-variation level, \n        -- so we can just sum up 0s and 1s to get totals at the campaign/flow-variation grain.\n        , sum(case when count_received_sms > 0 then 1 else 0 end) as unique_count_received_sms\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( count_clicked_sms ) as count_clicked_sms\n\n         -- only look at 'count' metrics for unique people counts\n        -- get unique number of people who did each kind of event\n        -- each record in person_campaign_flow is at the person-campaign/flow-variation level, \n        -- so we can just sum up 0s and 1s to get totals at the campaign/flow-variation grain.\n        , sum(case when count_clicked_sms > 0 then 1 else 0 end) as unique_count_clicked_sms\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( count_sent_sms ) as count_sent_sms\n\n         -- only look at 'count' metrics for unique people counts\n        -- get unique number of people who did each kind of event\n        -- each record in person_campaign_flow is at the person-campaign/flow-variation level, \n        -- so we can just sum up 0s and 1s to get totals at the campaign/flow-variation grain.\n        , sum(case when count_sent_sms > 0 then 1 else 0 end) as unique_count_sent_sms\n\n        \n        \n        -- sum up any person-level metrics to the flow/campaign level\n        , sum( count_unsubscribed_from_sms ) as count_unsubscribed_from_sms\n\n         -- only look at 'count' metrics for unique people counts\n        -- get unique number of people who did each kind of event\n        -- each record in person_campaign_flow is at the person-campaign/flow-variation level, \n        -- so we can just sum up 0s and 1s to get totals at the campaign/flow-variation grain.\n        , sum(case when count_unsubscribed_from_sms > 0 then 1 else 0 end) as unique_count_unsubscribed_from_sms\n\n        \n        from person_campaign_flow\n    group by 1,2,3,4\n)\n\nselect * from agg_metrics", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"int_klaviyo__campaign_flow_metrics\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:35.039374Z", "completed_at": "2024-08-30T20:19:35.340616Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:35.342932Z", "completed_at": "2024-08-30T20:19:35.342942Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.34087491035461426, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo.int_klaviyo__person_metrics", "compiled": true, "compiled_code": "with person_campaign_flow as (\n\n    select *\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__person_campaign_flow\"\n),\n\nagg_metrics as (\n\n    select\n        person_id,\n        source_relation,\n        count(distinct last_touch_campaign_id) as count_total_campaigns,\n        count(distinct last_touch_flow_id) as count_total_flows,\n        min(first_event_at) as first_event_at, -- first ever event occurred at\n        max(last_event_at) as last_event_at, -- last ever event occurred at\n        min(distinct case when last_touch_campaign_id is not null then first_event_at end) as first_campaign_touch_at,\n        max(distinct case when last_touch_campaign_id is not null then last_event_at end) as last_campaign_touch_at,\n        min(distinct case when last_touch_flow_id is not null then first_event_at end) as first_flow_touch_at,\n        max(distinct case when last_touch_flow_id is not null then last_event_at end) as last_flow_touch_at\n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( sum_revenue_refunded_order ) as total_sum_revenue_refunded_order\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n        , sum( case when coalesce(last_touch_campaign_id, last_touch_flow_id) is null then sum_revenue_refunded_order else 0 end ) as organic_sum_revenue_refunded_order\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( sum_revenue_placed_order ) as total_sum_revenue_placed_order\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n        , sum( case when coalesce(last_touch_campaign_id, last_touch_flow_id) is null then sum_revenue_placed_order else 0 end ) as organic_sum_revenue_placed_order\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( sum_revenue_ordered_product ) as total_sum_revenue_ordered_product\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n        , sum( case when coalesce(last_touch_campaign_id, last_touch_flow_id) is null then sum_revenue_ordered_product else 0 end ) as organic_sum_revenue_ordered_product\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( sum_revenue_checkout_started ) as total_sum_revenue_checkout_started\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n        , sum( case when coalesce(last_touch_campaign_id, last_touch_flow_id) is null then sum_revenue_checkout_started else 0 end ) as organic_sum_revenue_checkout_started\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( sum_revenue_cancelled_order ) as total_sum_revenue_cancelled_order\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n        , sum( case when coalesce(last_touch_campaign_id, last_touch_flow_id) is null then sum_revenue_cancelled_order else 0 end ) as organic_sum_revenue_cancelled_order\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( count_active_on_site ) as total_count_active_on_site\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( count_viewed_product ) as total_count_viewed_product\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( count_ordered_product ) as total_count_ordered_product\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( count_placed_order ) as total_count_placed_order\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( count_refunded_order ) as total_count_refunded_order\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( count_received_email ) as total_count_received_email\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( count_clicked_email ) as total_count_clicked_email\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( count_opened_email ) as total_count_opened_email\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( count_marked_email_as_spam ) as total_count_marked_email_as_spam\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( count_unsubscribed ) as total_count_unsubscribed\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( count_received_sms ) as total_count_received_sms\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( count_clicked_sms ) as total_count_clicked_sms\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( count_sent_sms ) as total_count_sent_sms\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n\n        \n        -- sum up any count/sum_revenue metrics -> prefix with `total` since we're pulling out organic sums as well\n        , sum( count_unsubscribed_from_sms ) as total_count_unsubscribed_from_sms\n\n        -- let's pull out the organic (not attributed to a flow or campaign) revenue sums\n        \n\n        from person_campaign_flow\n    group by 1,2\n\n)\n\nselect * from agg_metrics", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"int_klaviyo__person_metrics\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:35.370269Z", "completed_at": "2024-08-30T20:19:35.374843Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:35.375825Z", "completed_at": "2024-08-30T20:19:35.375831Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.017216920852661133, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo.dbt_utils_unique_combination_of_columns_int_klaviyo__campaign_flow_metrics_variation_id__source_relation__last_touch_campaign_id__last_touch_flow_id.3ea05faa81", "compiled": true, "compiled_code": "\n\n\n\n\n\nwith validation_errors as (\n\n    select\n        variation_id, source_relation, last_touch_campaign_id, last_touch_flow_id\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"int_klaviyo__campaign_flow_metrics\"\n    group by variation_id, source_relation, last_touch_campaign_id, last_touch_flow_id\n    having count(*) > 1\n\n)\n\nselect *\nfrom validation_errors\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:35.383150Z", "completed_at": "2024-08-30T20:19:35.386476Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:35.386736Z", "completed_at": "2024-08-30T20:19:35.386745Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.009421110153198242, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo.dbt_utils_unique_combination_of_columns_int_klaviyo__person_metrics_person_id__source_relation.4897d57f8b", "compiled": true, "compiled_code": "\n\n\n\n\n\nwith validation_errors as (\n\n    select\n        person_id, source_relation\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"int_klaviyo__person_metrics\"\n    group by person_id, source_relation\n    having count(*) > 1\n\n)\n\nselect *\nfrom validation_errors\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:35.377722Z", "completed_at": "2024-08-30T20:19:35.645179Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:35.645422Z", "completed_at": "2024-08-30T20:19:35.645429Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.29421329498291016, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo.klaviyo__persons", "compiled": true, "compiled_code": "with person as (\n\n    select *\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__person\"\n),\n\nperson_metrics as (\n\n    select *\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"int_klaviyo__person_metrics\"\n),\n\nperson_join as (\n\n    select\n        person.*,\n        \"count_total_campaigns\",\n  \"count_total_flows\",\n  \"first_event_at\",\n  \"last_event_at\",\n  \"first_campaign_touch_at\",\n  \"last_campaign_touch_at\",\n  \"first_flow_touch_at\",\n  \"last_flow_touch_at\",\n  \"total_sum_revenue_refunded_order\",\n  \"organic_sum_revenue_refunded_order\",\n  \"total_sum_revenue_placed_order\",\n  \"organic_sum_revenue_placed_order\",\n  \"total_sum_revenue_ordered_product\",\n  \"organic_sum_revenue_ordered_product\",\n  \"total_sum_revenue_checkout_started\",\n  \"organic_sum_revenue_checkout_started\",\n  \"total_sum_revenue_cancelled_order\",\n  \"organic_sum_revenue_cancelled_order\",\n  \"total_count_active_on_site\",\n  \"total_count_viewed_product\",\n  \"total_count_ordered_product\",\n  \"total_count_placed_order\",\n  \"total_count_refunded_order\",\n  \"total_count_received_email\",\n  \"total_count_clicked_email\",\n  \"total_count_opened_email\",\n  \"total_count_marked_email_as_spam\",\n  \"total_count_unsubscribed\",\n  \"total_count_received_sms\",\n  \"total_count_clicked_sms\",\n  \"total_count_sent_sms\",\n  \"total_count_unsubscribed_from_sms\"\n\n    from person\n    left join person_metrics on (\n        person.person_id = person_metrics.person_id\n        and person.source_relation = person_metrics.source_relation\n    )\n\n)\n\nselect *\nfrom person_join", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__persons\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:35.364558Z", "completed_at": "2024-08-30T20:19:35.651307Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:35.651648Z", "completed_at": "2024-08-30T20:19:35.651654Z"}], "thread_id": "Thread-4 (worker)", "execution_time": 0.3199179172515869, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo.klaviyo__flows", "compiled": true, "compiled_code": "with flow as (\n\n    select *\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__flow\"\n),\n\nflow_metrics as (\n\n    select *\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"int_klaviyo__campaign_flow_metrics\"\n),\n\nflow_join as (\n    \n    \n\n    select\n        flow.*, -- has flow_id and source_relation\n        \"variation_id\",\n  \"total_count_unique_people\",\n  \"first_event_at\",\n  \"last_event_at\",\n  \"sum_revenue_refunded_order\",\n  \"sum_revenue_placed_order\",\n  \"sum_revenue_ordered_product\",\n  \"sum_revenue_checkout_started\",\n  \"sum_revenue_cancelled_order\",\n  \"count_active_on_site\",\n  \"unique_count_active_on_site\",\n  \"count_viewed_product\",\n  \"unique_count_viewed_product\",\n  \"count_ordered_product\",\n  \"unique_count_ordered_product\",\n  \"count_placed_order\",\n  \"unique_count_placed_order\",\n  \"count_refunded_order\",\n  \"unique_count_refunded_order\",\n  \"count_received_email\",\n  \"unique_count_received_email\",\n  \"count_clicked_email\",\n  \"unique_count_clicked_email\",\n  \"count_opened_email\",\n  \"unique_count_opened_email\",\n  \"count_marked_email_as_spam\",\n  \"unique_count_marked_email_as_spam\",\n  \"count_unsubscribed\",\n  \"unique_count_unsubscribed\",\n  \"count_received_sms\",\n  \"unique_count_received_sms\",\n  \"count_clicked_sms\",\n  \"unique_count_clicked_sms\",\n  \"count_sent_sms\",\n  \"unique_count_sent_sms\",\n  \"count_unsubscribed_from_sms\",\n  \"unique_count_unsubscribed_from_sms\"\n\n    from flow\n    left join flow_metrics on (\n      flow.flow_id = flow_metrics.last_touch_flow_id\n      and\n      flow.source_relation = flow_metrics.source_relation\n    )\n),\n\nfinal as (\n\n    select \n        *,\n        md5(cast(coalesce(cast(flow_id as TEXT), '_dbt_utils_surrogate_key_null_') || '-' || coalesce(cast(variation_id as TEXT), '_dbt_utils_surrogate_key_null_') as TEXT)) as flow_variation_key\n\n    from flow_join\n)\n\nselect *\nfrom final", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__flows\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:35.359663Z", "completed_at": "2024-08-30T20:19:35.651868Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:35.652156Z", "completed_at": "2024-08-30T20:19:35.652160Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 0.3206961154937744, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.klaviyo.klaviyo__campaigns", "compiled": true, "compiled_code": "with campaign as (\n\n    select *\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"stg_klaviyo__campaign\"\n),\n\ncampaign_metrics as (\n\n    select *\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"int_klaviyo__campaign_flow_metrics\"\n),\n\ncampaign_join as (\n    \n    \n\n    select\n        campaign.*, -- has campaign_id and source_relation\n        \"variation_id\",\n  \"total_count_unique_people\",\n  \"first_event_at\",\n  \"last_event_at\",\n  \"sum_revenue_refunded_order\",\n  \"sum_revenue_placed_order\",\n  \"sum_revenue_ordered_product\",\n  \"sum_revenue_checkout_started\",\n  \"sum_revenue_cancelled_order\",\n  \"count_active_on_site\",\n  \"unique_count_active_on_site\",\n  \"count_viewed_product\",\n  \"unique_count_viewed_product\",\n  \"count_ordered_product\",\n  \"unique_count_ordered_product\",\n  \"count_placed_order\",\n  \"unique_count_placed_order\",\n  \"count_refunded_order\",\n  \"unique_count_refunded_order\",\n  \"count_received_email\",\n  \"unique_count_received_email\",\n  \"count_clicked_email\",\n  \"unique_count_clicked_email\",\n  \"count_opened_email\",\n  \"unique_count_opened_email\",\n  \"count_marked_email_as_spam\",\n  \"unique_count_marked_email_as_spam\",\n  \"count_unsubscribed\",\n  \"unique_count_unsubscribed\",\n  \"count_received_sms\",\n  \"unique_count_received_sms\",\n  \"count_clicked_sms\",\n  \"unique_count_clicked_sms\",\n  \"count_sent_sms\",\n  \"unique_count_sent_sms\",\n  \"count_unsubscribed_from_sms\",\n  \"unique_count_unsubscribed_from_sms\"\n\n    from campaign\n    left join campaign_metrics on (\n      campaign.campaign_id = campaign_metrics.last_touch_campaign_id\n      and\n      campaign.source_relation = campaign_metrics.source_relation\n    )\n),\n\nfinal as (\n\n    select \n        *,\n        md5(cast(coalesce(cast(campaign_id as TEXT), '_dbt_utils_surrogate_key_null_') || '-' || coalesce(cast(variation_id as TEXT), '_dbt_utils_surrogate_key_null_') as TEXT)) as campaign_variation_key\n\n    from campaign_join\n)\n\nselect *\nfrom final", "relation_name": "\"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__campaigns\""}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:35.682277Z", "completed_at": "2024-08-30T20:19:35.686507Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:35.687849Z", "completed_at": "2024-08-30T20:19:35.687857Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.010980844497680664, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo.not_null_klaviyo__persons_person_id.624a41e75a", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect person_id\nfrom \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__persons\"\nwhere person_id is null\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:35.678999Z", "completed_at": "2024-08-30T20:19:35.686945Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:35.688324Z", "completed_at": "2024-08-30T20:19:35.688328Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.01355600357055664, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo.dbt_utils_unique_combination_of_columns_klaviyo__persons_person_id__source_relation.b223d703b3", "compiled": true, "compiled_code": "\n\n\n\n\n\nwith validation_errors as (\n\n    select\n        person_id, source_relation\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__persons\"\n    group by person_id, source_relation\n    having count(*) > 1\n\n)\n\nselect *\nfrom validation_errors\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:35.688751Z", "completed_at": "2024-08-30T20:19:35.696592Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:35.697662Z", "completed_at": "2024-08-30T20:19:35.697669Z"}], "thread_id": "Thread-4 (worker)", "execution_time": 0.011927127838134766, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo.dbt_utils_unique_combination_of_columns_klaviyo__flows_flow_variation_key__source_relation.925d4118dc", "compiled": true, "compiled_code": "\n\n\n\n\n\nwith validation_errors as (\n\n    select\n        flow_variation_key, source_relation\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__flows\"\n    group by flow_variation_key, source_relation\n    having count(*) > 1\n\n)\n\nselect *\nfrom validation_errors\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:35.691899Z", "completed_at": "2024-08-30T20:19:35.696810Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:35.698059Z", "completed_at": "2024-08-30T20:19:35.698062Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 0.011837959289550781, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo.not_null_klaviyo__flows_flow_variation_key.152c0d960b", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect flow_variation_key\nfrom \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__flows\"\nwhere flow_variation_key is null\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:35.698386Z", "completed_at": "2024-08-30T20:19:35.704580Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:35.705229Z", "completed_at": "2024-08-30T20:19:35.705236Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.00936126708984375, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo.dbt_utils_unique_combination_of_columns_klaviyo__campaigns_campaign_variation_key__source_relation.e5d14aee28", "compiled": true, "compiled_code": "\n\n\n\n\n\nwith validation_errors as (\n\n    select\n        campaign_variation_key, source_relation\n    from \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__campaigns\"\n    group by campaign_variation_key, source_relation\n    having count(*) > 1\n\n)\n\nselect *\nfrom validation_errors\n\n\n", "relation_name": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-08-30T20:19:35.701411Z", "completed_at": "2024-08-30T20:19:35.704877Z"}, {"name": "execute", "started_at": "2024-08-30T20:19:35.705687Z", "completed_at": "2024-08-30T20:19:35.705691Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.009414196014404297, "adapter_response": {}, "message": null, "failures": null, "unique_id": "test.klaviyo.not_null_klaviyo__campaigns_campaign_variation_key.c4588cdadc", "compiled": true, "compiled_code": "\n    \n    \n\n\n\nselect campaign_variation_key\nfrom \"postgres\".\"klaviyo_integration_tests_klaviyo_dev\".\"klaviyo__campaigns\"\nwhere campaign_variation_key is null\n\n\n", "relation_name": null}], "elapsed_time": 2.82706618309021, "args": {"defer": false, "require_explicit_package_overrides_for_builtin_materializations": true, "require_resource_names_without_spaces": false, "profiles_dir": "/Users/joseph.markiewicz/.dbt", "quiet": false, "log_level_file": "debug", "log_path": "/Users/joseph.markiewicz/Documents/dbt_packages/klaviyo/dbt_klaviyo/integration_tests/logs", "introspect": true, "enable_legacy_logger": false, "version_check": true, "which": "generate", "log_file_max_bytes": 10485760, "macro_debugging": false, "use_colors": true, "populate_cache": true, "send_anonymous_usage_stats": true, "print": true, "indirect_selection": "eager", "static": false, "exclude": [], "strict_mode": false, "show_resource_report": false, "log_level": "info", "printer_width": 80, "log_format_file": "debug", "partial_parse_file_diff": true, "cache_selected_only": false, "target": "postgres", "empty_catalog": false, "vars": {}, "log_format": "default", "write_json": true, "source_freshness_run_project_hooks": false, "warn_error_options": {"include": [], "exclude": []}, "invocation_command": "dbt docs generate -t postgres", "static_parser": true, "project_dir": "/Users/joseph.markiewicz/Documents/dbt_packages/klaviyo/dbt_klaviyo/integration_tests", "use_colors_file": true, "compile": true, "partial_parse": true, "favor_state": false, "select": []}}